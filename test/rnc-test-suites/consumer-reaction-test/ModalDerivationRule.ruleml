<?xml version="1.0" encoding="UTF-8"?>

<?xml-model href="../../../relaxng/drivers/consumer-relaxed.rnc" type="application/relax-ng-compact-syntax"?>
<And xmlns="http://ruleml.org/spec" xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:ruleml = "http://ruleml.org/spec"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <!-- 
This example shows how the generic Operator is used as modal connective in modal logic programs

-->

  <!-- assert knowledge -->

    
    <!-- it is possible that -->
    <Operator type="ruleml:AlethicOperator" iri="ruleml:Possible">
      <Atom>
        <Rel>p</Rel>
      </Atom>
    </Operator>

    <!-- it is not necessary that not  (= it is possible that) -->
    <Neg>
      <Operator type="ruleml:AlethicOperator" iri="ruleml:Necessary">
        <Neg>
          <Atom>
            <Rel>p</Rel>
          </Atom>
        </Neg>
      </Operator>
    </Neg>

    <Equivalent>
      <!-- it is not necessary that -->
      <Neg>
        <Operator type="ruleml:AlethicOperator" iri="ruleml:Necessary">
          <Atom>
            <Rel>p</Rel>
          </Atom>
        </Operator>
      </Neg>
      <!-- it is possible that not -->
      <Operator type="ruleml:AlethicOperator" iri="ruleml:Possible">        
        <Neg>
          <Atom>
            <Rel>p</Rel>
          </Atom>
        </Neg>
      </Operator>
    </Equivalent>
 
    <!-- For all X it is necessary that p(X) -->
    <Forall>
      <Var>X</Var>
      <Operator type="ruleml:AlethicOperator" iri="ruleml:Necessary">
        <Atom>
          <Rel>p</Rel>
          <Var>X</Var>
        </Atom>
      </Operator>
    </Forall>

    <!-- Barcan formulae: it is necessary that for all X it is p(X) (= For all X it is necessary that p(X)) -->
    <Operator type="ruleml:AlethicOperator" iri="ruleml:Necessary">
      <Atom closure="universal">
        <Rel>p</Rel>
        <Var>X</Var>
      </Atom>
    </Operator>  
       
       
    <!-- modal rule: "if obliged(p(X)) then permitted(p(X))" -->    
    <Implies>
      <if>
        <Operator type="ruleml:DeonticOperator" iri="ruleml:Obliged">            
          <Atom>
            <Rel>p</Rel>
            <Var>X</Var>
          </Atom>
        </Operator>
      </if>
      <then>
        <Operator type="ruleml:DeonticOperator" iri="ruleml:Permitted"> 
          <Atom>
            <Rel>p</Rel>
            <Var>X</Var>
          </Atom>
        </Operator>   
      </then>
    </Implies>
    
    
    <!-- modal rule: "obliged(if p(X) then q(X))" -->
    
    <Operator type="ruleml:DeonticOperator" iri="ruleml:Obliged">
      <Implies>
        <if>
          <Atom>
              <Rel>p</Rel>
              <Var>X</Var>
          </Atom>
        </if>
        <then>
          <Atom>
              <Rel>q</Rel>
              <Var>X</Var>
          </Atom>
        </then>
      </Implies>
    </Operator>

    <!-- modal rule: "if obliged(p(X)) then obliged(q(X))" -->
    
   <Implies>
        <if>
          <Operator type="ruleml:DeonticOperator" iri="ruleml:Obliged">            
              <Atom>
                <Rel>p</Rel>
                <Var>X</Var>
              </Atom>
          </Operator>  
        </if>
        <then>
          <Operator type="ruleml:DeonticOperator" iri="ruleml:Obliged"> 
            <Atom>
              <Rel>q</Rel>
              <Var>X</Var>
            </Atom>
          </Operator>   
        </then>
   </Implies>

    <!-- modal rule: "if obliged(neg(p(X))) and p(X) then obliged(q(X))" (Contrary-to-duty obligation) -->
    
    <Implies>
      <if>
        <And>
          <Operator type="ruleml:DeonticOperator" iri="ruleml:Obliged">
            <Neg>            
              <Atom>
                <Rel>p</Rel>
                <Var>X</Var>
              </Atom>
            </Neg>  
          </Operator>

          <Atom>
            <Rel>p</Rel>
            <Var>X</Var>
          </Atom>
          
        </And>  
      </if>
      <then>
        <Operator type="ruleml:DeonticOperator" iri="ruleml:Obliged"> 
          <Atom>
            <Rel>q</Rel>
            <Var>X</Var>
          </Atom>
        </Operator>   
      </then>
    </Implies>


    <!-- reified modal rule: "if happens(p(X),T) and holds(forbidden(p(X)),T) then initiates(p(X),obliged(q(X)),T)" 
        (note: in KR Reaction RuleML this Event Calculus formalization is directly supported)  -->
    
    <Implies>
      <if>
        <Operator type="ruleml:Connective" iri="ruleml:And"> <!-- operator connective And -->
          
          <Atom>
            <Rel iri="ruleml:Happens"/>
            <Expr><Fun>p</Fun><Var>X</Var></Expr>
            <Time><Var>T</Var></Time>
          </Atom>
          
          <Atom>
            <Rel iri="ruleml:Holds"/>
            <Expr>
              <Fun iri="ruleml:Forbidden"/>
              <Expr><Fun>p</Fun><Var>X</Var></Expr>
            </Expr>
            <Time><Var>T</Var></Time>
          </Atom>  
          
        </Operator>  
      </if>
      <then>
        <Atom>
          <Rel iri="ruleml:Initiates"/>
          <Expr><Fun>p</Fun><Var>X</Var></Expr>
          <Expr>
            <Fun iri="ruleml:Obliged"/>
            <Expr><Fun>q</Fun><Var>X</Var></Expr>
          </Expr>
          <Time><Var>T</Var></Time>
        </Atom> 
      </then>
    </Implies>

</And>
