<?xml version="1.0" encoding="UTF-8"?><xs:schema xmlns:ruleml="http://ruleml.org/spec" xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" targetNamespace="http://ruleml.org/spec"><xs:import namespace="http://www.w3.org/XML/1998/namespace" schemaLocation="http://www.w3.org/2001/xml.xsd"/>
  
  <xs:group name="Node.choice">
    <xs:choice>
      <xs:choice>
        <xs:element ref="ruleml:Atom"/>
        <xs:element ref="ruleml:Rel"/>
      </xs:choice>
      <xs:choice>
        <xs:element ref="ruleml:And"/>
        <xs:element ref="ruleml:Or"/>
      </xs:choice>
      <xs:element ref="ruleml:Implies"/>
      <xs:choice>
        <xs:element ref="ruleml:Forall"/>
        <xs:element ref="ruleml:Exists"/>
      </xs:choice>
      <xs:choice>
        <xs:element ref="ruleml:Expr"/>
        <xs:element ref="ruleml:Fun"/>
      </xs:choice>
      <xs:element ref="ruleml:Neg"/>
      <xs:element ref="ruleml:Naf"/>
      <xs:element ref="ruleml:Equivalent"/>
      <xs:group ref="ruleml:Equal.Node.def"/>
      <xs:element ref="ruleml:Data"/>
      <xs:element ref="ruleml:Skolem"/>
      <xs:element ref="ruleml:Ind"/>
      <xs:element ref="ruleml:Var"/>
      <xs:group ref="ruleml:Plex_Any.Node.def"/>
      <xs:group ref="ruleml:Interval_formula.def"/>
      <xs:element ref="ruleml:Negation"/>
      <xs:element ref="ruleml:Operation"/>
      <xs:element ref="ruleml:Rule"/>
      <xs:group ref="ruleml:Spatial_formula.def"/>
      <xs:group ref="ruleml:IntervalAlgebraEqual"/>
      <xs:element ref="ruleml:After"/>
      <xs:element ref="ruleml:Before"/>
      <xs:element ref="ruleml:Every"/>
      <xs:element ref="ruleml:Any"/>
      <xs:element ref="ruleml:Timer"/>
      <xs:element ref="ruleml:During"/>
      <xs:element ref="ruleml:Overlaps"/>
      <xs:element ref="ruleml:Starts"/>
      <xs:element ref="ruleml:Precedes"/>
      <xs:element ref="ruleml:Succeeds"/>
      <xs:element ref="ruleml:Meets"/>
      <xs:element ref="ruleml:Finishes"/>
      <xs:group ref="ruleml:Time_formula.def"/>
    </xs:choice>
  </xs:group>
  <xs:group name="edge.choice">
    <xs:choice>
      <xs:group ref="ruleml:op_Atom.edge.def"/>
      <xs:choice>
        <xs:group ref="ruleml:formula_And.edge.def"/>
        <xs:group ref="ruleml:formula_Or.edge.def"/>
      </xs:choice>
      <xs:choice>
        <xs:group ref="ruleml:head_Implies.edge.def"/>
        <xs:group ref="ruleml:body_Implies.edge.def"/>
      </xs:choice>
      <xs:choice>
        <xs:element ref="ruleml:declare"/>
        <xs:group ref="ruleml:formula_Forall.edge.def"/>
        <xs:group ref="ruleml:formula_Exists.edge.def"/>
      </xs:choice>
      <xs:group ref="ruleml:op_Expr.edge.def"/>
      <xs:element ref="ruleml:degree"/>
      <xs:element ref="ruleml:strong"/>
      <xs:element ref="ruleml:weak"/>
      <xs:element ref="ruleml:torso"/>
      <xs:element ref="ruleml:oid"/>
      <xs:element ref="ruleml:slot"/>
      <xs:choice>
        <xs:element ref="ruleml:left"/>
        <xs:element ref="ruleml:right"/>
      </xs:choice>
      <xs:group ref="ruleml:arg.edge.def"/>
      <xs:element ref="ruleml:resl"/>
      <xs:element ref="ruleml:repo"/>
      <xs:group ref="ruleml:arg_interval.def"/>
      <xs:group ref="ruleml:formula-negation"/>
      <xs:group ref="ruleml:formula-Operation"/>
      <xs:group ref="ruleml:if_Rule.edge.def"/>
      <xs:group ref="ruleml:then_Rule.edge.def"/>
      <xs:group ref="ruleml:arg_spatial"/>
      <xs:group ref="ruleml:arg_time.def"/>
    </xs:choice>
  </xs:group>
  
  <xs:group name="SimpleFormula-node.choice">
    <xs:annotation>
      <xs:documentation>atomic formulas are a kind of simple formula</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:group ref="ruleml:Atom-node.choice"/>
      <xs:group ref="ruleml:Equal-node.choice"/>
    </xs:choice>
  </xs:group>
  <xs:group name="Atom-node.choice">
    <xs:annotation>
      <xs:documentation>an extension point for specializations of the atomic formula tag name.
      </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element ref="ruleml:Atom"/>
      <xs:group ref="ruleml:Interval_formula.def"/>
      <xs:group ref="ruleml:Spatial_formula.def"/>
      <xs:group ref="ruleml:Time_formula.def"/>
    </xs:choice>
  </xs:group>
  <xs:element name="Atom">
    <xs:annotation>
      <xs:documentation>&lt;Atom&gt;: a predicate applied to arguments. See
        http://ruleml.org/1.02/glossary/#gloss-Atom</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="ruleml:Atom.header"/>
        <xs:group ref="ruleml:Atom.main"/>
      </xs:sequence>
      <xs:attributeGroup ref="ruleml:reAtom.attlist"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="reAtom.attlist">
    <xs:annotation>
      <xs:documentation>Atomic formulas may have an optional closure attribute.</xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="ruleml:closure-att.choice"/>
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
    <xs:attribute name="style" type="ruleml:style.value">
      <xs:annotation>
        <xs:documentation>@style: defines a reference to a corresponding unique key. See
          http://www.reaction.ruleml.org/1.02/glossary/#gloss-@style</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  
  <xs:group name="operatorForAtoms-edge.choice">
    <xs:annotation>
      <xs:documentation>an extension point for stripe skipping as well as specializations of the
        operator tag name in atomic formulas.  </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:op_Atom.edge.def"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="op_Atom.edge.def">
    <xs:annotation>
      <xs:documentation>(context sensitive: see also expr_module and holog_module) An operator
        expression including a relation (&lt;Rel&gt;) of an atom (&lt;Atom&gt;).</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element form="qualified" name="op">
        <xs:annotation>
          <xs:documentation>&lt;op&gt;: edge (role) element for the predicate of an atomic formula. See
            http://ruleml.org/1.02/glossary/#gloss-op</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ruleml:op_Atom.content">
              <xs:attributeGroup ref="ruleml:op_Atom.attlist"/>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:complexType name="op_Atom.content">
    <xs:annotation>
      <xs:documentation>The operator role in the context of an atomic formula is filled by a
        predicate.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="ruleml:Relation-node.choice"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Relation-node.choice">
    <xs:annotation>
      <xs:documentation> </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element ref="ruleml:Rel"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="Rel">
    <xs:annotation>
      <xs:documentation>&lt;Rel&gt;: a category of name used as the predicate of an atomic formula. See
        http://ruleml.org/1.02/glossary/#gloss-Rel</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base="ruleml:Rel.content">
          <xs:attributeGroup ref="ruleml:reRel.attlist"/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="reRel.attlist">
    <xs:annotation>
      <xs:documentation>Relations accept the optional attribute pattern of
        resources.</xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="ruleml:Resource.attlist"/>
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
    <xs:attribute name="type" type="ruleml:type.value">
      <xs:annotation>
        <xs:documentation>A role for optionally specifying a term's (user-defined) type. See
          http://ruleml.org/1.02/glossary/#gloss-type</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:simpleType name="Rel.content">
    <xs:annotation>
      <xs:documentation>The content model for relations is the XSD datatype
        token.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:token"/>
  </xs:simpleType>
  
  
  <xs:group name="And-node.choice">
    <xs:annotation>
      <xs:documentation/>
    </xs:annotation>
    <xs:sequence>
      <xs:element ref="ruleml:And"/>
    </xs:sequence>
  </xs:group>
  <xs:element name="And">
    <xs:annotation>
      <xs:documentation>&lt;And&gt;: polyadic conjunction where &lt;And/&gt; is true. See
        http://ruleml.org/1.02/glossary/#gloss-And</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="ruleml:And.header"/>
        <xs:group ref="ruleml:And.main"/>
      </xs:sequence>
      <xs:attributeGroup ref="ruleml:reAnd.attlist"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="reAnd.attlist">
    <xs:annotation>
      <xs:documentation>The attribute list of the conjunction element will accept a scoped closure
        attribute at full first-order logic.</xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="ruleml:closure-att-fo.choice"/>
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
    <xs:attribute name="style" type="ruleml:style.value">
      <xs:annotation>
        <xs:documentation>@style: defines a reference to a corresponding unique key. See
          http://www.reaction.ruleml.org/1.02/glossary/#gloss-@style</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:group name="And.header">
    <xs:annotation>
      <xs:documentation>Conjunctions accept the header patter common to truth-valued
        connectives.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group minOccurs="0" ref="ruleml:TruthValuedConnective.header"/>
    </xs:sequence>
  </xs:group>
  
  <xs:group name="And.main">
    <xs:annotation>
      <xs:documentation>The main section of the conjunction content model contains zero or more
        formulas.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group maxOccurs="unbounded" minOccurs="0" ref="ruleml:formula_And-edge.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="formula_And-edge.choice">
    <xs:annotation>
      <xs:documentation>an extension point for stripe skipping as well as specializations of the
        formula tag name in conjunctions.  </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:formula_And.edge.def"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="formula_And.edge.def">
    <xs:annotation>
      <xs:documentation>The formula role of a conjunctive (&lt;And&gt;) expression,  Within And
        ...</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element form="qualified" name="formula">
        <xs:annotation>
          <xs:documentation>&lt;formula&gt;: contains a single formula. See
            http://ruleml.org/1.02/glossary/#gloss-formula</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ruleml:formula_And.content">
              <xs:attributeGroup ref="ruleml:formula_And.attlist"/>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:complexType name="formula_And.content">
    <xs:annotation>
      <xs:documentation>Formulas within conjunctions consist of a single formula</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="ruleml:AndFormula.choice"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="AndFormula.choice">
    <xs:annotation>
      <xs:documentation>formulas allowed to participate in conjunctions. </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:choice>
        <xs:group ref="ruleml:SimpleFormula-node.choice"/>
        <xs:group ref="ruleml:And-node.choice"/>
        <xs:group ref="ruleml:Or-node.choice"/>
        <xs:group ref="ruleml:Negation-node.choice"/>
        <xs:group ref="ruleml:NegationAsFailure-node.choice"/>
        <xs:group ref="ruleml:Implication-fo-node.choice"/>
        <xs:group ref="ruleml:Forall-fo-node.choice"/>
        <xs:group ref="ruleml:Exists-fo-node.choice"/>
      </xs:choice>
      <xs:group ref="ruleml:Operation-node.choice"/>
    </xs:choice>
  </xs:complexType>
  
  <xs:group name="Or-node.choice">
    <xs:annotation>
      <xs:documentation>an extension point for specializations of the disjunction tag name.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element ref="ruleml:Or"/>
    </xs:sequence>
  </xs:group>
  <xs:element name="Or">
    <xs:annotation>
      <xs:documentation>&lt;Or&gt;: polyadic disjunction where &lt;Or/&gt; is false. See
        http://ruleml.org/1.02/glossary/#gloss-Or</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="ruleml:Or.header"/>
        <xs:group ref="ruleml:Or.main"/>
      </xs:sequence>
      <xs:attributeGroup ref="ruleml:reOr.attlist"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="reOr.attlist">
    <xs:annotation>
      <xs:documentation>The attribute list of the disjunction element will accept a (scoped) closure
        attribute at full first-order logic.</xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="ruleml:closure-att-fo.choice"/>
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
    <xs:attribute name="style" type="ruleml:style.value">
      <xs:annotation>
        <xs:documentation>@style: defines a reference to a corresponding unique key. See
          http://www.reaction.ruleml.org/1.02/glossary/#gloss-@style</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:group name="Or.header">
    <xs:annotation>
      <xs:documentation>Disjunctions accept the header patter common to truth-valued
        connectives.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group minOccurs="0" ref="ruleml:TruthValuedConnective.header"/>
    </xs:sequence>
  </xs:group>
  
  <xs:group name="Or.main">
    <xs:annotation>
      <xs:documentation>The main section of the disjunction content model contains zero or more
        formulas.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group maxOccurs="unbounded" minOccurs="0" ref="ruleml:formula_Or-edge.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="formula_Or-edge.choice">
    <xs:annotation>
      <xs:documentation>an extension point for stripe skipping as well as specializations of the
        formula tag name in disjunctions.  </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:formula_Or.edge.def"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="formula_Or.edge.def">
    <xs:annotation>
      <xs:documentation>The formula role of a disjunctive (&lt;Or&gt;) expression, </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element form="qualified" name="formula">
        <xs:annotation>
          <xs:documentation/>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ruleml:formula_Or.content">
              <xs:attributeGroup ref="ruleml:formula_Or.attlist"/>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:complexType name="formula_Or.content">
    <xs:annotation>
      <xs:documentation>Formulas within disjunctions consist of a single formula</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="ruleml:OrFormula.choice"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="OrFormula.choice">
    <xs:annotation>
      <xs:documentation>formulas allowed to participate in disjunctions. </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:choice>
        <xs:group ref="ruleml:SimpleFormula-node.choice"/>
        <xs:group ref="ruleml:And-node.choice"/>
        <xs:group ref="ruleml:Or-node.choice"/>
        <xs:group ref="ruleml:Negation-node.choice"/>
        <xs:group ref="ruleml:NegationAsFailure-node.choice"/>
        <xs:group ref="ruleml:Implication-fo-node.choice"/>
        <xs:group ref="ruleml:Forall-fo-node.choice"/>
        <xs:group ref="ruleml:Exists-fo-node.choice"/>
      </xs:choice>
      <xs:group ref="ruleml:Operation-node.choice"/>
    </xs:choice>
  </xs:complexType>
  
  
  <xs:group name="Implication-node.choice">
    <xs:annotation>
      <xs:documentation>a convenience pattern that unifies implications and equivalences because
        equivalence is allowed wherever implication is allowed.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:group ref="ruleml:Implies-node.choice"/>
      <xs:group ref="ruleml:Equivalent-node.choice"/>
    </xs:choice>
  </xs:group>
  
  <xs:group name="Implies-node.choice">
    <xs:annotation>
      <xs:documentation>an extension point to allow alternate names and internationalization of
        uni-directional implication tag name.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element ref="ruleml:Implies"/>
    </xs:sequence>
  </xs:group>
  <xs:element name="Implies">
    <xs:annotation>
      <xs:documentation>&lt;Implies&gt;: an implication between two formulas, a premise and a conclusion.
        See  http://ruleml.org/1.02/glossary/#gloss-Implies</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="ruleml:Implies.header"/>
        <xs:group ref="ruleml:Implies.main"/>
      </xs:sequence>
      <xs:attributeGroup ref="ruleml:Implies-datt.choice"/>
      <xs:attributeGroup ref="ruleml:reImplies.attlist"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="reImplies.attlist">
    <xs:annotation>
      <xs:documentation>Implications may have an optional closure attribute  and will accept a
        scoped closure attribute at full first-order logic.</xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="ruleml:closure-att.choice"/>
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
    <xs:attribute name="style" type="ruleml:style.value">
      <xs:annotation>
        <xs:documentation>@style: defines a reference to a corresponding unique key. See
          http://www.reaction.ruleml.org/1.02/glossary/#gloss-@style</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  
  <xs:group name="Implies.header">
    <xs:annotation>
      <xs:documentation>Equations accept the header of truth-valued connectives</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group minOccurs="0" ref="ruleml:TruthValuedConnective.header"/>
    </xs:sequence>
  </xs:group>
  
  
  <xs:group name="body_Implies.name.choice">
    <xs:annotation>
      <xs:documentation> an extension point for stripe skipping as well as specializations of the if
        tag name in implications.  </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:body_Implies.edge.def"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="body_Implies.edge.def">
    <xs:annotation>
      <xs:documentation>The if of an implication rule (&lt;Implies&gt;) containing the Premise(s), also
        known as the "antecedent" part of the rule.  Also used as the "antecedent" part of an
        entailment (&lt;Entails&gt;). Within Implies...</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element form="qualified" name="if">
        <xs:annotation>
          <xs:documentation>&lt;if&gt;: contains the premise of the implication. See
            http://ruleml.org/1.02/glossary/#gloss-if FIXME: replace body_ with if_ and head_ with
            then_</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ruleml:body_Implies.content">
              <xs:attributeGroup ref="ruleml:body_Implies.attlist"/>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:complexType name="body_Implies.content">
    <xs:annotation>
      <xs:documentation>The premise of an implication consists of a single
        formula</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="ruleml:PremiseFormula.choice"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="PremiseFormula.choice">
    <xs:annotation>
      <xs:documentation>formulas allowed to be premises. </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:choice>
        <xs:group ref="ruleml:SimpleFormula-node.choice"/>
        <xs:group ref="ruleml:And-node.choice"/>
        <xs:group ref="ruleml:Or-node.choice"/>
        <xs:group ref="ruleml:Negation-node.choice"/>
        <xs:group ref="ruleml:NegationAsFailure-node.choice"/>
        <xs:group ref="ruleml:Implication-fo-node.choice"/>
        <xs:group ref="ruleml:Forall-fo-node.choice"/>
        <xs:group ref="ruleml:Exists-fo-node.choice"/>
      </xs:choice>
      <xs:group ref="ruleml:Operation-node.choice"/>
    </xs:choice>
  </xs:complexType>
  
  <xs:group name="head_Implies.name.choice">
    <xs:annotation>
      <xs:documentation>an extension point for stripe skipping as well as specializations of the
        then tag name in implications.  </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:head_Implies.edge.def"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="head_Implies.edge.def">
    <xs:annotation>
      <xs:documentation>The then of an implication rule (&lt;Implies&gt;) containing the conclusion, also
        known as the "consequent" or "then" part of the rule.  Also used as the "consequent" part of
        an entailment (&lt;Entails&gt;). Within Implies...</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element form="qualified" name="then">
        <xs:annotation>
          <xs:documentation>&lt;then&gt;: contains the conclusion of the implication. See
            http://ruleml.org/1.02/glossary/#gloss-then</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ruleml:head_Implies.content">
              <xs:attributeGroup ref="ruleml:head_Implies.attlist"/>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:complexType name="head_Implies.content">
    <xs:annotation>
      <xs:documentation>The conclusion of an implication consists of a single
        formula.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="ruleml:ConclusionFormula.choice"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ConclusionFormula.choice">
    <xs:annotation>
      <xs:documentation>formulas allowed to be conclusions include atomic formulas.
      </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:choice>
        <xs:group ref="ruleml:Atom-head-node.choice"/>
        <xs:group ref="ruleml:Equal-head-node.choice"/>
        <xs:group ref="ruleml:And-head-node.choice"/>
        <xs:group ref="ruleml:Or-head-node.choice"/>
        <xs:group ref="ruleml:Negation-head-node.choice"/>
        <xs:group ref="ruleml:Implication-head-node.choice"/>
        <xs:group ref="ruleml:Forall-head-node.choice"/>
        <xs:group ref="ruleml:Exists-head-node.choice"/>
      </xs:choice>
      <xs:group ref="ruleml:Operation-node.choice"/>
    </xs:choice>
  </xs:complexType>
  <xs:group name="Atom-head-node.choice">
    <xs:annotation>
      <xs:documentation>backbone patterns    </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:Atom-node.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="Equal-head-node.choice">
    <xs:sequence>
      <xs:group ref="ruleml:Equal-node.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="And-head-node.choice">
    <xs:sequence>
      <xs:group ref="ruleml:And-fo-node.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="Or-head-node.choice">
    <xs:sequence>
      <xs:group ref="ruleml:Or-fo-node.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="Negation-head-node.choice">
    <xs:sequence>
      <xs:group ref="ruleml:Negation-node.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="Implication-head-node.choice">
    <xs:sequence>
      <xs:group ref="ruleml:Implication-fo-node.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="Forall-head-node.choice">
    <xs:sequence>
      <xs:group ref="ruleml:Forall-fo-node.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="Exists-head-node.choice">
    <xs:sequence>
      <xs:group ref="ruleml:Exists-fo-node.choice"/>
    </xs:sequence>
  </xs:group>
  
  
  <xs:group name="Forall-node.choice">
    <xs:annotation>
      <xs:documentation>an extension point to allow alternate names and internationalization of
        universal quantifiers</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element ref="ruleml:Forall"/>
    </xs:sequence>
  </xs:group>
  <xs:element name="Forall">
    <xs:annotation>
      <xs:documentation>Explicit universal quantifier. It consists of a sequence of one or more
        variables (&lt;Var&gt;), each optionally surrounded by a &lt;declare&gt; role, and a logical formula
        (optionally surrounded by a &lt;formula&gt; role). See
        http://ruleml.org/1.02/glossary/#gloss-Forall</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="ruleml:Forall.header"/>
        <xs:group ref="ruleml:Forall.main"/>
      </xs:sequence>
      <xs:attributeGroup ref="ruleml:reForall.attlist"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="reForall.attlist">
    <xs:annotation>
      <xs:documentation>The attribute list of the universal quantification formula  will accept a
        scoped closure attribute at full first-order logic.</xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="ruleml:closure-att-fo.choice"/>
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
    <xs:attribute name="style" type="ruleml:style.value">
      <xs:annotation>
        <xs:documentation>@style: defines a reference to a corresponding unique key. See
          http://www.reaction.ruleml.org/1.02/glossary/#gloss-@style</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:group name="Forall.header">
    <xs:annotation>
      <xs:documentation>Universally qualified formulas aaccept the header patter common to
        truth-valued connectives.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group minOccurs="0" ref="ruleml:TruthValuedConnective.header"/>
    </xs:sequence>
  </xs:group>
  
  <xs:group name="Forall.main">
    <xs:annotation>
      <xs:documentation>Universally qualified formulas contain a sequence of bound variables and one
        formula.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:boundVariables.choice"/>
      <xs:group ref="ruleml:formula_Forall-edge.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="Exists-node.choice">
    <xs:annotation>
      <xs:documentation>an extension point to allow alternate names and internationalization for
        existential quantifiers</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element ref="ruleml:Exists"/>
    </xs:sequence>
  </xs:group>
  <xs:element name="Exists">
    <xs:annotation>
      <xs:documentation>Explicit existential quantifier. It consists of one or more variables (&lt;Var&gt;),
        each optionally surrounded by a &lt;declare&gt; role, followed by a logical formula  (optionally
        surrounded by a &lt;formula&gt; role). See
        http://ruleml.org/1.02/glossary/#gloss-Exists</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="ruleml:Exists.header"/>
        <xs:group ref="ruleml:Exists.main"/>
      </xs:sequence>
      <xs:attributeGroup ref="ruleml:reExists.attlist"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="reExists.attlist">
    <xs:annotation>
      <xs:documentation>The attribute list of the existential quantification formula  will accept a
        scoped closure attribute at full first-order logic.</xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="ruleml:closure-att-fo.choice"/>
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
    <xs:attribute name="style" type="ruleml:style.value">
      <xs:annotation>
        <xs:documentation>@style: defines a reference to a corresponding unique key. See
          http://www.reaction.ruleml.org/1.02/glossary/#gloss-@style</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:group name="Exists.header">
    <xs:annotation>
      <xs:documentation>Existential quantifications accept the header patter common to truth-valued
        connectives.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group minOccurs="0" ref="ruleml:TruthValuedConnective.header"/>
    </xs:sequence>
  </xs:group>
  
  <xs:group name="Exists.main">
    <xs:annotation>
      <xs:documentation>Existentially qualified formulas contain a sequence of bound variables and
        one formula.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:boundVariables.choice"/>
      <xs:group ref="ruleml:formula_Exists-edge.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="boundVariables.choice">
    <xs:annotation>
      <xs:documentation>declaration of one or more bound quantifiable terms.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group maxOccurs="unbounded" ref="ruleml:declare-edge.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="declare-edge.choice">
    <xs:annotation>
      <xs:documentation>an extension point for stripe skipping as well as specializations of the
        declare tag name in quantified formulas.  </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element ref="ruleml:declare"/>
    </xs:sequence>
  </xs:group>
  <xs:element name="declare">
    <xs:annotation>
      <xs:documentation>A role used for variables (&lt;Var&gt;) declared within a quantifier (&lt;Forall&gt; or
        &lt;Exists&gt;). See http://ruleml.org/1.02/glossary/#gloss-declare</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="ruleml:declare.content">
          <xs:attributeGroup ref="ruleml:declare.attlist"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:complexType name="declare.content">
    <xs:annotation>
      <xs:documentation>a declaration element contains a single quantifiable term</xs:documentation>
    </xs:annotation>
    <xs:group ref="ruleml:SimpleQuantifiableTerm.choice"/>
  </xs:complexType>
  <xs:group name="formula_Forall-edge.choice">
    <xs:annotation>
      <xs:documentation>an extension point for stripe skipping as well as specializations of the
        formula tag name in universal quantifications. </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:formula_Forall.edge.def"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="formula_Forall.edge.def">
    <xs:sequence>
      <xs:element form="qualified" name="formula">
        <xs:annotation>
          <xs:documentation>The formula role of a conjunctive (&lt;And&gt;) or disjunctive (&lt;Or&gt;) expression,
            quantifier (&lt;Forall&gt; or &lt;Exists&gt;), or performative (&lt;Assert&gt;, &lt;Query&gt; or &lt;Retract&gt;). See
            http://ruleml.org/1.02/glossary/#gloss-formula within Forall...</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ruleml:formula_Forall.content">
              <xs:attributeGroup ref="ruleml:formula_Forall.attlist"/>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:complexType name="formula_Forall.content">
    <xs:annotation>
      <xs:documentation>The formula role of universal quantifications contains a single formula.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="ruleml:ForallFormula.choice"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ForallFormula.choice">
    <xs:annotation>
      <xs:documentation>formulas allowed to be universally quantified.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:choice>
        <xs:group ref="ruleml:SimpleFormula-node.choice"/>
        <xs:group ref="ruleml:And-fo-node.choice"/>
        <xs:group ref="ruleml:Or-fo-node.choice"/>
        <xs:group ref="ruleml:Negation-node.choice"/>
        <xs:group ref="ruleml:Implication-node.choice"/>
        <xs:group ref="ruleml:Forall-node.choice"/>
        <xs:group ref="ruleml:Exists-fo-node.choice"/>
      </xs:choice>
      <xs:group ref="ruleml:Operation-node.choice"/>
    </xs:choice>
  </xs:complexType>
  
  <xs:group name="formula_Exists-edge.choice">
    <xs:annotation>
      <xs:documentation>an extension point for stripe skipping as well as specializations of the
        formula tag name in existential quantifications. </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:formula_Exists.edge.def"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="formula_Exists.edge.def">
    <xs:sequence>
      <xs:element form="qualified" name="formula">
        <xs:annotation>
          <xs:documentation>The formula role of a conjunctive (&lt;And&gt;) or disjunctive (&lt;Or&gt;) expression,
            quantifier (&lt;Forall&gt; or &lt;Exists&gt;), or performative (&lt;Assert&gt;, &lt;Query&gt; or &lt;Retract&gt;). See
            http://ruleml.org/1.02/glossary/#gloss-formula Within Exists...</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ruleml:formula_Exists.content">
              <xs:attributeGroup ref="ruleml:formula_Exists.attlist"/>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:complexType name="formula_Exists.content">
    <xs:annotation>
      <xs:documentation>The formula role of existential quantifications contains a single
        formula.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="ruleml:ExistsFormula.choice"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ExistsFormula.choice">
    <xs:annotation>
      <xs:documentation>formulas allowed to be existentially quantified.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:choice>
        <xs:group ref="ruleml:SimpleFormula-node.choice"/>
        <xs:group ref="ruleml:And-node.choice"/>
        <xs:group ref="ruleml:Or-node.choice"/>
        <xs:group ref="ruleml:Negation-node.choice"/>
        <xs:group ref="ruleml:Implication-fo-node.choice"/>
        <xs:group ref="ruleml:Forall-fo-node.choice"/>
        <xs:group ref="ruleml:Exists-node.choice"/>
      </xs:choice>
      <xs:group ref="ruleml:Operation-node.choice"/>
    </xs:choice>
  </xs:complexType>
  
  
  <xs:group name="Expression-node.choice">
    <xs:annotation>
      <xs:documentation>an extension point for specializations of the expression tag name.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element ref="ruleml:Expr"/>
    </xs:sequence>
  </xs:group>
  <xs:element name="Expr">
    <xs:annotation>
      <xs:documentation>&lt;Expr&gt;: a functional expression. See
        http://ruleml.org/1.02/glossary/#gloss-Expr</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="ruleml:Expr.main">
          <xs:attributeGroup ref="ruleml:reExpr.attlist"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:group name="operatorForExpressions-edge.choice">
    <xs:annotation>
      <xs:documentation>an extension point for stripe skipping as well as specializations of the
        operator tag name in expressions. </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:op_Expr.edge.def"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="op_Expr.edge.def">
    <xs:annotation>
      <xs:documentation>(context sensitive: see Also atom_backbone_module and holog_module) An
        operator expression including a function name (&lt;Fun&gt;) of a (&lt;Expr&gt;).
        http://ruleml.org/1.02/glossary/#gloss-op</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element form="qualified" name="op">
        <xs:annotation>
          <xs:documentation>Also an operator in functional expressions.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ruleml:op_Expr.content">
              <xs:attributeGroup ref="ruleml:op_Expr.attlist"/>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:complexType name="op_Expr.content">
    <xs:annotation>
      <xs:documentation>The operator role of an expression is filled by a
        functor.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="ruleml:Function-node.choice"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Function-node.choice">
    <xs:annotation>
      <xs:documentation>an extension point for specializations of the function operator tag name.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element ref="ruleml:Fun"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="Fun">
    <xs:annotation>
      <xs:documentation>&lt;Fun&gt;: a type of name for functional operators. See
        http://ruleml.org/1.02/glossary/#gloss-Fun</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base="ruleml:Fun.content">
          <xs:attributeGroup ref="ruleml:reFun.attlist"/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="reFun.attlist">
    <xs:annotation>
      <xs:documentation>functors accept the resource attribute list</xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="ruleml:Resource.attlist"/>
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
    <xs:attribute name="type" type="ruleml:type.value">
      <xs:annotation>
        <xs:documentation>A role for optionally specifying a term's (user-defined) type. See
          http://ruleml.org/1.02/glossary/#gloss-type</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  
  <xs:simpleType name="Fun.content">
    <xs:annotation>
      <xs:documentation>A functor contains the XSD datatype token.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:token"/>
  </xs:simpleType>
  
  
  <xs:group name="And-fo-node.choice">
    <xs:sequence>
      <xs:group ref="ruleml:And-node.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="Or-fo-node.choice">
    <xs:sequence>
      <xs:group ref="ruleml:Or-node.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="Negation-fo-node.choice">
    <xs:sequence>
      <xs:group ref="ruleml:Negation-node.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="Implication-fo-node.choice">
    <xs:sequence>
      <xs:group ref="ruleml:Implication-node.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="Forall-fo-node.choice">
    <xs:sequence>
      <xs:group ref="ruleml:Forall-node.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="Exists-fo-node.choice">
    <xs:sequence>
      <xs:group ref="ruleml:Exists-node.choice"/>
    </xs:sequence>
  </xs:group>
  
  
  <xs:attributeGroup name="closure-att-fo.choice">
    <xs:attributeGroup ref="ruleml:closure-att.choice"/>
  </xs:attributeGroup>
  
  
  <xs:attributeGroup name="Implies-datt.choice">
    <xs:annotation>
      <xs:documentation>implications have inference direction and material implication as an
        attribute with default values.  implications have scoped attributes that are activated at
        full first-order logic</xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="ruleml:material-att-inf.choice"/>
  </xs:attributeGroup>
  
  
  
  <xs:attributeGroup name="material-att-inf.choice">
    <xs:attributeGroup ref="ruleml:material-att.choice"/>
  </xs:attributeGroup>
  
  
  
  
  
  
  
  <xs:group name="termsForAtoms.nonemptysequence.choice">
    <xs:annotation>
      <xs:documentation/>
    </xs:annotation>
    <xs:sequence>
      <xs:group maxOccurs="unbounded" ref="ruleml:positionalArgument-edge.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="termsForExpressions.nonemptysequence.choice">
    <xs:sequence>
      <xs:group maxOccurs="unbounded" ref="ruleml:positionalArgument-edge.choice"/>
    </xs:sequence>
  </xs:group>
  
  <xs:group name="Atom.main">
    <xs:annotation>
      <xs:documentation>Pre-fix operator notation for atomic formulas is required in a normal-form
        serialization.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:sequence>
        <xs:group ref="ruleml:operatorForAtoms-edge.choice"/>
        <xs:group ref="ruleml:argumentsForAtoms.sequence"/>
      </xs:sequence>
      <xs:group ref="ruleml:argumentsForAtoms.sequence"/>
    </xs:choice>
  </xs:group>
  <xs:group name="argumentsForAtoms.sequence">
    <xs:annotation>
      <xs:documentation>Slotted arguments follow positional arguments in atomic formulas in the
        normal-form serialization. </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:positionalArgumentsForAtoms.sequence"/>
      <xs:group ref="ruleml:slotsForAtoms.sequence"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="positionalArgumentsForAtoms.sequence">
    <xs:annotation>
      <xs:documentation>Positional rest arguments follow the ordinary positional arguments in atomic
        formulas in the normal-form serialization. </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:termsForAtoms.sequence"/>
      <xs:group minOccurs="0" ref="ruleml:restOfPositionalArguments-edge.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="slotsForAtoms.sequence">
    <xs:annotation>
      <xs:documentation>Slotted rest arguments follow the ordinary slots in atomic formulas in the
        normal-form serialization. </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:slotTermsForAtoms.sequence"/>
      <xs:group minOccurs="0" ref="ruleml:restOfSlots-edge.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:complexType name="Expr.main">
    <xs:annotation>
      <xs:documentation>Pre-fix operator notation for expressions is required in the normal-form
        serialization.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:sequence>
        <xs:group ref="ruleml:operatorForExpressions-edge.choice"/>
        <xs:group ref="ruleml:argumentsForExpressions.sequence"/>
      </xs:sequence>
      <xs:group ref="ruleml:argumentsForExpressions.sequence"/>
    </xs:choice>
  </xs:complexType>
  <xs:group name="argumentsForExpressions.sequence">
    <xs:annotation>
      <xs:documentation>Slotted arguments follow positional arguments in expressions in the
        normal-form serialization. </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:sequence minOccurs="0">
        <xs:group ref="ruleml:positionalArgumentsForExpressions.sequence"/>
        <xs:group ref="ruleml:slotsForExpressions.sequence"/>
      </xs:sequence>
    </xs:sequence>
  </xs:group>
  <xs:group name="positionalArgumentsForExpressions.sequence">
    <xs:annotation>
      <xs:documentation>Positional rest arguments follow the ordinary positional arguments in
        expressions in the normal-form serialization. </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:sequence minOccurs="0">
        <xs:group ref="ruleml:termsForExpressions.sequence"/>
        <xs:group minOccurs="0" ref="ruleml:restOfPositionalArguments-edge.choice"/>
      </xs:sequence>
    </xs:sequence>
  </xs:group>
  <xs:group name="slotsForExpressions.sequence">
    <xs:annotation>
      <xs:documentation>Slotted rest arguments follow the ordinary slots in expressions in the
        normal-form serialization. </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:sequence minOccurs="0">
        <xs:group ref="ruleml:slotTermsForExpressions.sequence"/>
        <xs:group minOccurs="0" ref="ruleml:restOfSlots-edge.choice"/>
      </xs:sequence>
    </xs:sequence>
  </xs:group>
  <xs:group name="Implies.main">
    <xs:annotation>
      <xs:documentation>In the normal-form serialization, the if and then of an implication must
        occur in canonical order.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:body_Implies.name.choice"/>
      <xs:group ref="ruleml:head_Implies.name.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="TruthValuedConnective.header">
    <xs:annotation>
      <xs:documentation>In the normal-form serialization, the order of header elements is: an
        optional header element sequence as defined in Node.header, followed by optional object
        identifier and degree</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group minOccurs="0" ref="ruleml:degree-edge.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="Atom.header">
    <xs:sequence>
      <xs:sequence minOccurs="0">
        <xs:group minOccurs="0" ref="ruleml:objectIdentifier-edge.choice"/>
        <xs:group minOccurs="0" ref="ruleml:degree-edge.choice"/>
      </xs:sequence>
    </xs:sequence>
  </xs:group>
  
  
  
  
  <xs:group name="argumentsForTime.sequence">
    <xs:choice>
      <xs:sequence>
        <xs:group maxOccurs="unbounded" minOccurs="0" ref="ruleml:arg_time.choice"/>
        <xs:group minOccurs="0" ref="ruleml:restOfPositionalArguments-edge.choice"/>
        <xs:group maxOccurs="unbounded" minOccurs="0" ref="ruleml:slot-edge.choice"/>
        <xs:group minOccurs="0" ref="ruleml:restOfSlots-edge.choice"/>
      </xs:sequence>
      <xs:group maxOccurs="unbounded" minOccurs="0" ref="ruleml:time_anycontent"/>
    </xs:choice>
  </xs:group>
  <xs:group name="argumentsForSpatial.sequence">
    <xs:choice>
      <xs:sequence>
        <xs:group maxOccurs="unbounded" minOccurs="0" ref="ruleml:arg_spatial.choice"/>
        <xs:group minOccurs="0" ref="ruleml:restOfPositionalArguments-edge.choice"/>
        <xs:group maxOccurs="unbounded" minOccurs="0" ref="ruleml:slot-edge.choice"/>
        <xs:group minOccurs="0" ref="ruleml:restOfSlots-edge.choice"/>
      </xs:sequence>
      <xs:group maxOccurs="unbounded" minOccurs="0" ref="ruleml:spatial_anycontent"/>
    </xs:choice>
  </xs:group>
  
  <xs:group name="Rule.main">
    <xs:sequence>
      <xs:group ref="ruleml:if_Rule-edge.choice"/>
      <xs:group ref="ruleml:then_Rule-edge.choice"/>
    </xs:sequence>
  </xs:group>
  
  <xs:group name="Rule.header">
    <xs:sequence>
      <xs:group minOccurs="0" ref="ruleml:degree-edge.choice"/>
    </xs:sequence>
  </xs:group>
  
  
  <xs:simpleType name="AbsIRI.datatype">
    <xs:restriction base="xs:string">
      <xs:pattern value="[\i-[:]][\c-[:]]+:.+"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="PrefixedCURIE.datatype">
    <xs:restriction base="xs:string">
      <xs:pattern value="(([\i-[:]][\c-[:]]*)?:)(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"/>
      <xs:minLength value="1"/>
    </xs:restriction>
  </xs:simpleType>
  
  
  <xs:attributeGroup name="Resource.attlist">
    <xs:annotation>
      <xs:documentation>attribute list for resources includes and optional iri
        attribute.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="iri" type="ruleml:iri.value">
      <xs:annotation>
        <xs:documentation>An attribute for referring to a IRI.     See
          http://ruleml.org/1.02/glossary/#gloss-@iri</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="iri-att.choice">
    <xs:annotation>
      <xs:documentation>an extension point for specializations of the oriented equation attribute
        name.  </xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="ruleml:iri.attrib.def"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="iri.attrib.def">
    <xs:attribute name="iri" type="ruleml:iri.value" use="required">
      <xs:annotation>
        <xs:documentation>An attribute for referring to a IRI.     See
          http://ruleml.org/1.02/glossary/#gloss-@iri</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:simpleType name="iri.value">
    <xs:union memberTypes="ruleml:PrefixedCURIE.datatype ruleml:AbsIRI.datatype"/>
  </xs:simpleType>
  
  <xs:element name="iri">
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base="ruleml:iri.content">
          <xs:attributeGroup ref="ruleml:iri.attlist"/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>
  <xs:simpleType name="iri.content">
    <xs:restriction base="ruleml:iri.value"/>
  </xs:simpleType>
  
  
  <xs:group name="degree-edge.choice">
    <xs:sequence>
      <xs:element ref="ruleml:degree"/>
    </xs:sequence>
  </xs:group>
  <xs:element name="degree">
    <xs:annotation>
      <xs:documentation>An optional uncertainty value (between 0.0 and 1.0) that may be assigned to
        simple formulas. See http://ruleml.org/1.02/glossary/#gloss-degree</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="ruleml:degree.content">
          <xs:attributeGroup ref="ruleml:degree.attlist"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:complexType name="degree.content">
    <xs:annotation>
      <xs:documentation>The degree edge element contains a single data term.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="ruleml:Data_degree-node.choice"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Data_degree-node.choice">
    <xs:group ref="ruleml:DataTerm.choice"/>
  </xs:complexType>
  
  
  <xs:group name="Negation-node.choice">
    <xs:annotation>
      <xs:documentation>an extension point for specializations of the strong negation tag name.
      </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element ref="ruleml:Neg"/>
      <xs:element ref="ruleml:Negation"/>
    </xs:choice>
  </xs:group>
  <xs:element name="Neg">
    <xs:annotation>
      <xs:documentation>A classical negation of a logical atom (&lt;Atom&gt;) (i.e. classical or "strong"
        negation).  The negated atom may be optionally surrounded by a &lt;strong&gt; role.        See
        http://ruleml.org/1.02/glossary/#gloss-Neg</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="ruleml:Neg.header"/>
        <xs:group ref="ruleml:Neg.main"/>
      </xs:sequence>
      <xs:attributeGroup ref="ruleml:reNeg.attlist"/>
    </xs:complexType>
  </xs:element>
  
  <xs:attributeGroup name="reNeg.attlist">
    <xs:attributeGroup ref="ruleml:closure-att-fo.choice"/>
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
    <xs:attribute name="style" type="ruleml:style.value">
      <xs:annotation>
        <xs:documentation>@style: defines a reference to a corresponding unique key. See
          http://www.reaction.ruleml.org/1.02/glossary/#gloss-@style</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:group name="Neg.header">
    <xs:annotation>
      <xs:documentation>Negation formulas accept the header patter common to truth-valued
        connectives.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group minOccurs="0" ref="ruleml:TruthValuedConnective.header"/>
    </xs:sequence>
  </xs:group>
  
  <xs:group name="Neg.main">
    <xs:annotation>
      <xs:documentation>Negation formulas contain a single role.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:strong-edge.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="strong-edge.choice">
    <xs:annotation>
      <xs:documentation>an extension point for stripe skipping as well as specializations of the
        strong tag name in strong negations. </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element ref="ruleml:strong"/>
    </xs:sequence>
  </xs:group>
  <xs:element name="strong">
    <xs:annotation>
      <xs:documentation>A role used for logical negation (&lt;Neg&gt;).        See
        http://ruleml.org/1.02/glossary/#gloss-strong</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="ruleml:strong.content">
          <xs:attributeGroup ref="ruleml:strong.attlist"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:complexType name="strong.content">
    <xs:annotation>
      <xs:documentation>The negation role contains a single formula. </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="ruleml:NegFormula.choice"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="NegFormula.choice">
    <xs:annotation>
      <xs:documentation>formulas allowed to belong to strong negation formulas include atomic
        formulas. </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:choice>
        <xs:group ref="ruleml:SimpleFormula-node.choice"/>
        <xs:group ref="ruleml:And-fo-node.choice"/>
        <xs:group ref="ruleml:Or-fo-node.choice"/>
        <xs:group ref="ruleml:Negation-fo-node.choice"/>
        <xs:group ref="ruleml:Implication-fo-node.choice"/>
        <xs:group ref="ruleml:Forall-fo-node.choice"/>
        <xs:group ref="ruleml:Exists-fo-node.choice"/>
      </xs:choice>
      <xs:group ref="ruleml:Operation-node.choice"/>
    </xs:choice>
  </xs:complexType>
  
  
  <xs:group name="NegationAsFailure-node.choice">
    <xs:annotation>
      <xs:documentation>an extension point for specializations of the weak negation tag name.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element ref="ruleml:Naf"/>
    </xs:sequence>
  </xs:group>
  <xs:element name="Naf">
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="ruleml:Naf.header"/>
        <xs:group ref="ruleml:Naf.main"/>
      </xs:sequence>
      <xs:attributeGroup ref="ruleml:reNaf.attlist"/>
    </xs:complexType>
  </xs:element>
  
  <xs:attributeGroup name="reNaf.attlist">
    <xs:attributeGroup ref="ruleml:closure-att-fo.choice"/>
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
    <xs:attribute name="style" type="ruleml:style.value">
      <xs:annotation>
        <xs:documentation>@style: defines a reference to a corresponding unique key. See
          http://www.reaction.ruleml.org/1.02/glossary/#gloss-@style</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:group name="Naf.header">
    <xs:annotation>
      <xs:documentation>Negation As Failure formulas accept the header patter common to truth-valued
        connectives.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group minOccurs="0" ref="ruleml:TruthValuedConnective.header"/>
    </xs:sequence>
  </xs:group>
  
  <xs:group name="Naf.main">
    <xs:annotation>
      <xs:documentation>Negation As Failure formulas contain a single role.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:weak-edge.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="weak-edge.choice">
    <xs:annotation>
      <xs:documentation>an extension point for stripe skipping as well as specializations of the
        weak tag name in weak negations. </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element ref="ruleml:weak"/>
    </xs:sequence>
  </xs:group>
  <xs:element name="weak">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="ruleml:weak.content">
          <xs:attributeGroup ref="ruleml:weak.attlist"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:complexType name="weak.content">
    <xs:annotation>
      <xs:documentation>The negation role contains a single formula. </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="ruleml:NafFormula.choice"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="NafFormula.choice">
    <xs:annotation>
      <xs:documentation>formulas allowed to belong to weak negation formulas include atomic
        forumulas. </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:group ref="ruleml:SimpleFormula-node.choice"/>
      <xs:group ref="ruleml:And-fo-node.choice"/>
      <xs:group ref="ruleml:Or-fo-node.choice"/>
      <xs:group ref="ruleml:Negation-node.choice"/>
      <xs:group ref="ruleml:Implication-fo-node.choice"/>
      <xs:group ref="ruleml:Forall-fo-node.choice"/>
      <xs:group ref="ruleml:Exists-fo-node.choice"/>
    </xs:choice>
  </xs:complexType>
  
  <xs:attributeGroup name="commonInit.attlist">
    <xs:annotation>
      <xs:documentation> </xs:documentation>
    </xs:annotation>
    <xs:attribute ref="xml:base"/>
    <xs:attribute ref="xml:id"/>
    <xs:attribute name="key" type="ruleml:key.value"/>
    <xs:attribute name="keyref" type="ruleml:keyref.value"/>
  </xs:attributeGroup>
  
  
  
  
  
  <xs:group name="Equivalent-node.choice">
    <xs:annotation>
      <xs:documentation>an extension point for specializations of the equivalence tag name.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element ref="ruleml:Equivalent"/>
    </xs:sequence>
  </xs:group>
  <xs:element name="Equivalent">
    <xs:annotation>
      <xs:documentation>&lt;Equivalent&gt;: Syntactic sugar for two implications. See
        http://ruleml.org/1.02/glossary/#gloss-Equivalent </xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="ruleml:Equivalent.header"/>
        <xs:group ref="ruleml:Equivalent.main"/>
      </xs:sequence>
      <xs:attributeGroup ref="ruleml:reEquivalent.attlist"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="reEquivalent.attlist">
    <xs:annotation>
      <xs:documentation>Equivalences may have an optional closure attribute  and will accept a
        scoped closure attribute at full first-order logic.</xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="ruleml:closure-att.choice"/>
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
    <xs:attribute name="style" type="ruleml:style.value">
      <xs:annotation>
        <xs:documentation>@style: defines a reference to a corresponding unique key. See
          http://www.reaction.ruleml.org/1.02/glossary/#gloss-@style</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  
  <xs:group name="Equivalent.header">
    <xs:annotation>
      <xs:documentation>Equivalences accept the header patter common to truth-valued
        connectives.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group minOccurs="0" ref="ruleml:TruthValuedConnective.header"/>
    </xs:sequence>
  </xs:group>
  
  <xs:group name="Equivalent.main">
    <xs:annotation>
      <xs:documentation>the main content model of equivalances consists of two "torso"
        formulas</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:torso-edge.choice"/>
      <xs:group ref="ruleml:torso-edge.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="torso-edge.choice">
    <xs:annotation>
      <xs:documentation>an extension point for stripe skipping as well as specializations of the
        torso tag name in equivalences.  </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element ref="ruleml:torso"/>
    </xs:sequence>
  </xs:group>
  <xs:element name="torso">
    <xs:annotation>
      <xs:documentation>&lt;torso&gt;: contains one formula within an equivalence. See
        http://ruleml.org/1.02/glossary/#gloss-torso </xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="ruleml:torso.content">
          <xs:attributeGroup ref="ruleml:torso.attlist"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:complexType name="torso.content">
    <xs:annotation>
      <xs:documentation>An equivalance is syntactic sugar for two implications. In all RuleML
        languages, formulas allowed as premises are the same or more general than those allowed as
        conclusions, because this is a requirement for the statement "P implies P" to be
        syntactically valid whenever P is a valid conclusion. Therefore, formulas allowed in
        equivalences are the same as those allowed in conclusions.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="ruleml:ConclusionFormula.choice"/>
    </xs:complexContent>
  </xs:complexType>
  
  
  <xs:attributeGroup name="material-att.choice">
    <xs:annotation>
      <xs:documentation>an extension point for specializations of the material implication attribute
        name.  </xs:documentation>
    </xs:annotation>
    <xs:attribute name="material" type="ruleml:material.value">
      <xs:annotation>
        <xs:documentation> An attribute indicating the kind of an implication rule (&lt;Implies&gt;).
          Allowed values are "yes" (the default) and "no". See
          http://ruleml.org/1.02/glossary/#gloss-@material</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="material.attrib.def">
    <xs:attribute name="material" type="ruleml:material.value" use="required">
      <xs:annotation>
        <xs:documentation> An attribute indicating the kind of an implication rule (&lt;Implies&gt;).
          Allowed values are "yes" (the default) and "no". See
          http://ruleml.org/1.02/glossary/#gloss-@material</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:simpleType name="material.value">
    <xs:union memberTypes="ruleml:material_default.value ruleml:material_non-default.value"/>
  </xs:simpleType>
  
  
  
  
  <xs:simpleType name="material_non-default.value">
    <xs:union memberTypes="ruleml:PrefixedCURIE.datatype ruleml:AbsIRI.datatype">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="no"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>
  
  
  <xs:simpleType name="material_default.value">
    <xs:restriction base="xs:token">
      <xs:enumeration value="yes"/>
    </xs:restriction>
  </xs:simpleType>
  
  
  <xs:group name="objectIdentifier-edge.choice">
    <xs:annotation>
      <xs:documentation>an extension point for stripe skipping as well as specializations of the
        object identifier tag name.  </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element ref="ruleml:oid"/>
    </xs:sequence>
  </xs:group>
  <xs:element name="oid">
    <xs:annotation>
      <xs:documentation>&lt;oid&gt;: a label for Node elements. See
        http://ruleml.org/1.02/glossary/#gloss-oid</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="ruleml:oid.content">
          <xs:attributeGroup ref="ruleml:oid.attlist"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:complexType name="oid.content">
    <xs:annotation>
      <xs:documentation>The object descriptor content model consists of any single term. Note: this
        corrects an error in the oid content model of RuleML 1.0, where Var is allowed in oid in
        bindatagroundlog and bindatagroundfact.</xs:documentation>
    </xs:annotation>
    <xs:group ref="ruleml:AnyTerm.choice"/>
  </xs:complexType>
  
  
  <xs:group name="slotTermsForAtoms.sequence">
    <xs:annotation>
      <xs:documentation>In atomic formulas, zero or more slots are allowed.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group maxOccurs="unbounded" minOccurs="0" ref="ruleml:slot-edge.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="slotTermsForExpressions.sequence">
    <xs:annotation>
      <xs:documentation>In expressions, zero or more slots are allowed.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group maxOccurs="unbounded" minOccurs="0" ref="ruleml:slot-edge.choice"/>
    </xs:sequence>
  </xs:group>
  
  <xs:group name="slot-edge.choice">
    <xs:annotation>
      <xs:documentation>an extension point for specializations of the slot tag name.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element ref="ruleml:slot"/>
    </xs:sequence>
  </xs:group>
  <xs:element name="slot">
    <xs:annotation>
      <xs:documentation>A user-defined slot (property). See
        http://ruleml.org/1.02/glossary/#gloss-slot</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="ruleml:slot.content">
          <xs:attributeGroup ref="ruleml:reslot.attlist"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="reslot.attlist">
    <xs:annotation>
      <xs:documentation>The slot element accepts optional cardinality and  weight attributes.
      </xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="ruleml:cardinality-att.choice"/>
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:complexType name="slot.content">
    <xs:annotation>
      <xs:documentation>The slot content model consists of a key (first position) and a filler
        (second position).</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:slotKeyTerm.choice"/>
      <xs:group ref="ruleml:slotFillerTerm.choice"/>
    </xs:sequence>
  </xs:complexType>
  <xs:group name="slotKeyTerm.choice">
    <xs:annotation>
      <xs:documentation>The key (first position) in a slot contains an interpreted term or data,
        which may be simple or compound.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:group ref="ruleml:SimpleKeyTerm.choice"/>
      <xs:group ref="ruleml:CompoundTerm.choice"/>
    </xs:choice>
  </xs:group>
  
  <xs:group name="slotFillerTerm.choice">
    <xs:annotation>
      <xs:documentation>The filler (second position) in a slot contains any single
        term.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:AnyTerm.choice"/>
    </xs:sequence>
  </xs:group>
  
  
  <xs:attributeGroup name="cardinality-att.choice">
    <xs:annotation>
      <xs:documentation>an extension point for specializations of the cardinality attribute name.
      </xs:documentation>
    </xs:annotation>
    <xs:attribute name="card" type="ruleml:cardinality.value">
      <xs:annotation>
        <xs:documentation>the cardinality of a slot.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="card.attrib.def">
    <xs:annotation>
      <xs:documentation>An attribute optionally specifying a &lt;slot&gt;'s cardinality. See
        http://ruleml.org/1.02/glossary/#gloss-card</xs:documentation>
    </xs:annotation>
    <xs:attribute name="card" type="ruleml:cardinality.value" use="required">
      <xs:annotation>
        <xs:documentation>the cardinality of a slot.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:simpleType name="cardinality.value">
    <xs:restriction base="xs:nonNegativeInteger"/>
  </xs:simpleType>
  
  
  
  
  <xs:group name="Equal-node.choice">
    <xs:annotation>
      <xs:documentation>an extension point for specializations of the equation tag name.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:Equal.Node.def"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="Equal.Node.def">
    <xs:annotation>
      <xs:documentation>An equational formula consisting of two expressions, each of which contains
        an argument and may be optionally surrounded  by a left (&lt;left&gt;) or a right (&lt;right&gt;)
        role.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element form="qualified" name="Equal">
        <xs:annotation>
          <xs:documentation>&lt;Equal&gt;: an equation between two terms. See
            http://ruleml.org/1.02/glossary/#gloss-Equal</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:group ref="ruleml:Equal.header"/>
            <xs:group ref="ruleml:Equal.main"/>
          </xs:sequence>
          <xs:attributeGroup ref="ruleml:reEqual.attlist"/>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="reEqual.attlist">
    <xs:attributeGroup ref="ruleml:closure-att-fo.choice"/>
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
    <xs:attribute name="style" type="ruleml:style.value">
      <xs:annotation>
        <xs:documentation>@style: defines a reference to a corresponding unique key. See
          http://www.reaction.ruleml.org/1.02/glossary/#gloss-@style</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:group name="Equal.header">
    <xs:annotation>
      <xs:documentation>Equations accept the header of truth-valued connectives</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group minOccurs="0" ref="ruleml:TruthValuedConnective.header"/>
    </xs:sequence>
  </xs:group>
  
  <xs:group name="Equal.main">
    <xs:annotation>
      <xs:documentation>Equations contain a pair of terms, a left-hand side and a right-hand
        side.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:leftSide-edge.choice"/>
      <xs:group ref="ruleml:rightSide-edge.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="leftSide-edge.choice">
    <xs:annotation>
      <xs:documentation>an extension point for stripe skipping as well as specializations of the
        left-hand side tag name in equations.  </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element ref="ruleml:left"/>
    </xs:sequence>
  </xs:group>
  <xs:element name="left">
    <xs:annotation>
      <xs:documentation>&lt;left&gt;: The left-hand side of an equation. See
        http://ruleml.org/1.02/glossary/#gloss-left</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="ruleml:left.content">
          <xs:attributeGroup ref="ruleml:left.attlist"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:complexType name="left.content">
    <xs:annotation>
      <xs:documentation>The left-hand side role in an equation is filled by a
        term.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="ruleml:leftTerm.choice"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:group name="rightSide-edge.choice">
    <xs:annotation>
      <xs:documentation>an extension point for stripe skipping as well as specializations of the
        right-hand side tag name in equations.  </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element ref="ruleml:right"/>
    </xs:sequence>
  </xs:group>
  <xs:element name="right">
    <xs:annotation>
      <xs:documentation>&lt;right&gt;: The right-hand side of an equation. See
        http://ruleml.org/1.02/glossary/#gloss-right</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="ruleml:right.content">
          <xs:attributeGroup ref="ruleml:right.attlist"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:complexType name="right.content">
    <xs:annotation>
      <xs:documentation>The right-hand side role in an equation is filled by a
        term.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="ruleml:rightTerm.choice"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="leftTerm.choice">
    <xs:annotation>
      <xs:documentation>terms allowed in the left-hand side of an equation </xs:documentation>
    </xs:annotation>
    <xs:group ref="ruleml:AnyTerm.choice"/>
  </xs:complexType>
  <xs:complexType name="rightTerm.choice">
    <xs:annotation>
      <xs:documentation>terms allowed in the right-hand side of an equation </xs:documentation>
    </xs:annotation>
    <xs:group ref="ruleml:AnyTerm.choice"/>
  </xs:complexType>
  
  
  <xs:attributeGroup name="Type.attlist">
    <xs:annotation>
      <xs:documentation>attribute list for objects that can have user-defined types, includes an
        optional type attribute.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="type" type="ruleml:type.value">
      <xs:annotation>
        <xs:documentation>A role for optionally specifying a term's (user-defined) type. See
          http://ruleml.org/1.02/glossary/#gloss-type</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="type-att.choice">
    <xs:annotation>
      <xs:documentation>an extension point for specializations of the oriented equation attribute
        name.  </xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="ruleml:type.attrib.def"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="type.attrib.def">
    <xs:attribute name="type" type="ruleml:type.value" use="required">
      <xs:annotation>
        <xs:documentation>A role for optionally specifying a term's (user-defined) type. See
          http://ruleml.org/1.02/glossary/#gloss-type</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:simpleType name="type.value">
    <xs:union memberTypes="ruleml:PrefixedCURIE.datatype ruleml:AbsIRI.datatype"/>
  </xs:simpleType>
  
  
  
  
  <xs:group name="DataTerm.choice">
    <xs:annotation>
      <xs:documentation>Data terms may have mixed content from any namespace.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:Data_any-node.choice"/>
    </xs:sequence>
  </xs:group>
  
  
  <xs:group name="Data_any-node.choice">
    <xs:annotation>
      <xs:documentation>an extension point for specializations of the data tag name.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element ref="ruleml:Data"/>
    </xs:sequence>
  </xs:group>
  <xs:element name="Data" type="xs:anyType"/>
  <xs:group name="anyElement.choice">
    <xs:annotation>
      <xs:documentation/>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:anyElement.def"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="anyElement.def">
    <xs:sequence>
      <xs:any processContents="lax"/>
    </xs:sequence>
  </xs:group>
  
  
  <xs:group name="Skolem-node.choice">
    <xs:annotation>
      <xs:documentation>an extension point to allow alternate names and internationalization for
        Skolem constants</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element ref="ruleml:Skolem"/>
    </xs:sequence>
  </xs:group>
  <xs:element name="Skolem">
    <xs:annotation>
      <xs:documentation>A Skolem individual constant, like RDF's blank nodes. See
        http://ruleml.org/1.02/glossary/#gloss-Skolem</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base="ruleml:Skolem.content">
          <xs:attributeGroup ref="ruleml:reSkolem.attlist"/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="reSkolem.attlist">
    <xs:annotation>
      <xs:documentation>Skolems optionally accept the attribute pattern of objects with user-defined
        types.</xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="ruleml:Type.attlist"/>
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
  </xs:attributeGroup>
  <xs:simpleType name="Skolem.content">
    <xs:annotation>
      <xs:documentation>The content model for skolems is the XSD datatype token.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:token"/>
  </xs:simpleType>
  
  
  <xs:group name="positionalArgument-edge.choice">
    <xs:annotation>
      <xs:documentation>an extension point for stripe skipping as well as specializations of the
        positional argument tag name. </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:arg.edge.def"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="arg.edge.def">
    <xs:annotation>
      <xs:documentation>A role used for the positional arguments of a logical atom (&lt;Atom&gt;), i.e. any
        of the following: &lt;Ind&gt;, &lt;Data&gt;, &lt;Var&gt;, &lt;Skolem&gt; or &lt;Reify&gt; (also &lt;Expr&gt; and &lt;Plex&gt; in non-Datalog
        sublanguages).</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element form="qualified" name="arg">
        <xs:annotation>
          <xs:documentation>&lt;arg&gt;: one argument of an atomic formula. See
            http://ruleml.org/1.02/glossary/#gloss-arg</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:group ref="ruleml:arg.content"/>
          <xs:attributeGroup ref="ruleml:arg-datt.choice"/>
          <xs:attributeGroup ref="ruleml:rearg.attlist"/>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="arg-datt.choice">
    <xs:attributeGroup ref="ruleml:index-attrib.choice"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="index-attrib.choice">
    <xs:annotation>
      <xs:documentation/>
    </xs:annotation>
    <xs:attribute name="index" type="ruleml:index.value">
      <xs:annotation>
        <xs:documentation>A required attribute for specifying the position of a positional argument
          (&lt;arg&gt;) within a logical atom (&lt;Atom&gt;). See
          http://ruleml.org/1.02/glossary/#gloss-index</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="index.attrib.def">
    <xs:attribute name="index" type="ruleml:index.value" use="required">
      <xs:annotation>
        <xs:documentation>A required attribute for specifying the position of a positional argument
          (&lt;arg&gt;) within a logical atom (&lt;Atom&gt;). See
          http://ruleml.org/1.02/glossary/#gloss-index</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:simpleType name="index.value">
    <xs:restriction base="xs:positiveInteger"/>
  </xs:simpleType>
  <xs:group name="arg.content">
    <xs:annotation>
      <xs:documentation>The content model of positional arguments for atomic formulas consists of
        any single term.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:AnyTerm.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="AnyTerm.choice">
    <xs:annotation>
      <xs:documentation>Terms may be simple or compound. Simple terms are either constant or
        quantifiable (variable).</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:group ref="ruleml:SimpleConstantTerm.choice"/>
      <xs:group ref="ruleml:SimpleQuantifiableTerm.choice"/>
      <xs:group ref="ruleml:CompoundTerm.choice"/>
    </xs:choice>
  </xs:group>
  
  <xs:group name="SimpleConstantTerm.choice">
    <xs:annotation>
      <xs:documentation>Skolem constants are simple constant terms, but are not used in keys.
      </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:group ref="ruleml:Skolem-node.choice"/>
      <xs:group ref="ruleml:SimpleKeyTerm.choice"/>
    </xs:choice>
  </xs:group>
  
  
  <xs:group name="SimpleKeyTerm.choice">
    <xs:annotation>
      <xs:documentation>Individuals and literals (data) are simple, constant terms, and may be used
        in slot keys.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:choice>
        <xs:group ref="ruleml:Individual-node.choice"/>
        <xs:group ref="ruleml:DataTerm.choice"/>
      </xs:choice>
      <xs:group ref="ruleml:Interval_term.def"/>
      <xs:group ref="ruleml:Spatial_term.def"/>
      <xs:group ref="ruleml:Time_term.def"/>
    </xs:choice>
  </xs:group>
  <xs:group name="CompoundTerm.choice">
    <xs:annotation>
      <xs:documentation>Data terms are literals, and may have simple or complex
        datatypes.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:group ref="ruleml:Expression-node.choice"/>
      <xs:group ref="ruleml:Plex_Any-node.choice"/>
    </xs:choice>
  </xs:group>
  
  
  <xs:group name="Individual-node.choice">
    <xs:annotation>
      <xs:documentation>an extension point for specializations of the individual tag name.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element ref="ruleml:Ind"/>
    </xs:sequence>
  </xs:group>
  <xs:element name="Ind">
    <xs:annotation>
      <xs:documentation>&lt;Ind&gt;: an individual constant. See
        http://ruleml.org/1.02/glossary/#gloss-Ind</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base="ruleml:Ind.content">
          <xs:attributeGroup ref="ruleml:reInd.attlist"/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="reInd.attlist">
    <xs:annotation>
      <xs:documentation>Individuals optionally accept the attribute patterns of resources, and
        objects with user-defined types.</xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="ruleml:Resource.attlist"/>
    <xs:attributeGroup ref="ruleml:Type.attlist"/>
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
  </xs:attributeGroup>
  
  <xs:simpleType name="Ind.content">
    <xs:annotation>
      <xs:documentation>The content model for individuals is the XSD datatype
        token.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:token"/>
  </xs:simpleType>
  <xs:group name="termsForAtoms.sequence">
    <xs:sequence>
      <xs:group minOccurs="0" ref="ruleml:termsForAtoms.nonemptysequence.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="termsForExpressions.sequence">
    <xs:sequence>
      <xs:group minOccurs="0" ref="ruleml:termsForExpressions.nonemptysequence.choice"/>
    </xs:sequence>
  </xs:group>
  
  
  <xs:group name="SimpleQuantifiableTerm.choice">
    <xs:annotation>
      <xs:documentation>terms that can be bound by a quantifier include
        variables.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:Variable-node.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="Variable-node.choice">
    <xs:annotation>
      <xs:documentation>an extension point for specializations of the variable tag name.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element ref="ruleml:Var"/>
    </xs:sequence>
  </xs:group>
  <xs:element name="Var">
    <xs:annotation>
      <xs:documentation>A logical variable, as in logic programming. See
        http://ruleml.org/1.02/glossary/#gloss-Var</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base="ruleml:Var.content">
          <xs:attributeGroup ref="ruleml:reVar.attlist"/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="reVar.attlist">
    <xs:annotation>
      <xs:documentation>Variables optionally accept the attribute pattern of objects with
        user-defined types.</xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="ruleml:Type.attlist"/>
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
  </xs:attributeGroup>
  <xs:simpleType name="Var.content">
    <xs:annotation>
      <xs:documentation>The content model for variables is the XSD datatype
        token.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:token"/>
  </xs:simpleType>
  
  
  <xs:attributeGroup name="closure-att.choice">
    <xs:annotation>
      <xs:documentation>an extension point for specializations of the implicit closure attribute
        name.  </xs:documentation>
    </xs:annotation>
    <xs:attribute name="closure" type="ruleml:closure.value">
      <xs:annotation>
        <xs:documentation>An attribute indicating how the contained free variables are quantified.
          Allowed values are "universal" and "existential". See
          http://ruleml.org/1.02/glossary/#gloss-@closure</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="closure.attrib.def">
    <xs:attribute name="closure" type="ruleml:closure.value" use="required">
      <xs:annotation>
        <xs:documentation>An attribute indicating how the contained free variables are quantified.
          Allowed values are "universal" and "existential". See
          http://ruleml.org/1.02/glossary/#gloss-@closure</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:simpleType name="closure.value">
    <xs:union memberTypes="ruleml:PrefixedCURIE.datatype ruleml:AbsIRI.datatype">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="universal"/>
          <xs:enumeration value="existential"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>
  
  
  
  
  <xs:group name="restOfSlots-edge.choice">
    <xs:annotation>
      <xs:documentation>an extension point for specializations of the slotted rest tag name.
        Stripe-skipping is not allowed for slotted rest variables.  </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element ref="ruleml:resl"/>
    </xs:sequence>
  </xs:group>
  <xs:element name="resl">
    <xs:annotation>
      <xs:documentation>A slotted rest variable used in &lt;Atom&gt;s, &lt;Expr&gt;s and &lt;Plex&gt;s.  Note that &lt;Plex&gt;s are
        generated, so &lt;resl&gt;s are only available above the Datalog sublanguage. See
        http://ruleml.org/1.02/glossary/#gloss-resl</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="ruleml:resl.content">
          <xs:attributeGroup ref="ruleml:resl.attlist"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:complexType name="resl.content">
    <xs:annotation>
      <xs:documentation>The content model of a slotted rest variable is a single
        term.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="ruleml:reslTerm.choice"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="reslTerm.choice">
    <xs:annotation>
      <xs:documentation>terms allowed in slotted rest variables. </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:group ref="ruleml:SlotSequenceMarker.choice"/>
      <xs:group ref="ruleml:Plex_resl-node.choice"/>
    </xs:choice>
  </xs:complexType>
  
  <xs:group name="SlotSequenceMarker.choice">
    <xs:annotation>
      <xs:documentation>Sequence markers are represented as ordinary variables.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:Variable-node.choice"/>
    </xs:sequence>
  </xs:group>
  
  
  
  <xs:group name="restOfPositionalArguments-edge.choice">
    <xs:annotation>
      <xs:documentation>an extension point for specializations of the positional rest tag name.
        Stripe-skipping is not allowed for positional rest variables.  </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element ref="ruleml:repo"/>
    </xs:sequence>
  </xs:group>
  <xs:element name="repo">
    <xs:annotation>
      <xs:documentation>A positional rest variable used in &lt;Atom&gt;s, &lt;Expr&gt;s and &lt;Plex&gt;s.  Note that &lt;Plex&gt;s
        are generated, so &lt;repo&gt;s are only available above the Datalog sublanguage.        See
        http://www.ruleml.org/0.9/glossary/#gloss-repo</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="ruleml:repo.content">
          <xs:attributeGroup ref="ruleml:repo.attlist"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:complexType name="repo.content">
    <xs:annotation>
      <xs:documentation>The content model of a positional rest variable is a single
        term.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="ruleml:repoTerm.choice"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="repoTerm.choice">
    <xs:annotation>
      <xs:documentation>terms allowed in positional rest variables include sequence markers.
      </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:group ref="ruleml:SequenceMarker.choice"/>
      <xs:group ref="ruleml:Plex_repo-node.choice"/>
    </xs:choice>
  </xs:complexType>
  
  <xs:group name="SequenceMarker.choice">
    <xs:annotation>
      <xs:documentation>Sequence markers are represented as ordinary variables.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:Variable-node.choice"/>
    </xs:sequence>
  </xs:group>
  
  
  <xs:group name="Plex_Any-node.choice">
    <xs:annotation>
      <xs:documentation>an extension point for specializations of the generalized list tag name.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:Plex_Any.Node.def"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="Plex_Any.Node.def">
    <xs:sequence>
      <xs:element form="qualified" name="Plex">
        <xs:annotation>
          <xs:documentation>A collection of (ordered) arguments (optionally enclosed by &lt;arg&gt;) and/or
            (unordered) user-defined slots (&lt;slot&gt;),  identical to an uninterpreted expression (&lt;Expr
            in="no"&gt;) except not having a user-specified function name (equivalent  to having a
            system-specified constructor 'Plex'). Rest variables (&lt;repo&gt; and &lt;resl&gt;) are also permitted.
            See http://ruleml.org/1.02/glossary/#gloss-Plex within Atom</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ruleml:Plex_Any.main">
              <xs:attributeGroup ref="ruleml:rePlex.attlist"/>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:group>
  
  <xs:complexType name="Plex_Any.main">
    <xs:annotation>
      <xs:documentation>A generalized list contains a generalized term sequence, which may be
        empty.</xs:documentation>
    </xs:annotation>
    <xs:group ref="ruleml:argumentsForExpressions.sequence"/>
  </xs:complexType>
  
  <xs:group name="Plex_repo-node.choice">
    <xs:annotation>
      <xs:documentation>an extension point for specializations of the generalized list tag name.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:Plex_repo.Node.def"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="Plex_repo.Node.def">
    <xs:sequence>
      <xs:element form="qualified" name="Plex">
        <xs:annotation>
          <xs:documentation>A collection of (ordered) arguments (optionally enclosed by &lt;arg&gt;) and/or
            (unordered) user-defined slots (&lt;slot&gt;),  identical to an uninterpreted expression (&lt;Expr
            in="no"&gt;) except not having a user-specified function name (equivalent  to having a
            system-specified constructor 'Plex'). Rest variables (&lt;repo&gt; and &lt;resl&gt;) are also permitted.
            See http://ruleml.org/1.02/glossary/#gloss-Plex within repo</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ruleml:Plex_repo.main">
              <xs:attributeGroup ref="ruleml:rePlex.attlist"/>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:complexType name="Plex_repo.main">
    <xs:annotation>
      <xs:documentation>A generalized list within a positional rest variable contains a positional
        argument sequence</xs:documentation>
    </xs:annotation>
    <xs:group ref="ruleml:positionalArgumentsForExpressions.sequence"/>
  </xs:complexType>
  
  <xs:group name="Plex_resl-node.choice">
    <xs:annotation>
      <xs:documentation>an extension point for specializations of the generalized list tag name.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:Plex_resl.Node.def"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="Plex_resl.Node.def">
    <xs:sequence>
      <xs:element form="qualified" name="Plex">
        <xs:annotation>
          <xs:documentation>A collection of (ordered) arguments (optionally enclosed by &lt;arg&gt;) and/or
            (unordered) user-defined slots (&lt;slot&gt;),  identical to an uninterpreted expression (&lt;Expr
            in="no"&gt;) except not having a user-specified function name (equivalent  to having a
            system-specified constructor 'Plex'). Rest variables (&lt;repo&gt; and &lt;resl&gt;) are also permitted.
            See http://ruleml.org/1.02/glossary/#gloss-Plex within resl</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ruleml:Plex_resl.main">
              <xs:attributeGroup ref="ruleml:rePlex.attlist"/>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:complexType name="Plex_resl.main">
    <xs:annotation>
      <xs:documentation>A generalized list within a slotted rest variable contains a slotted
        argument sequence</xs:documentation>
    </xs:annotation>
    <xs:group ref="ruleml:slotsForExpressions.sequence"/>
  </xs:complexType>
  
  
  
  
  
  
  <xs:attributeGroup name="reAnd-Query.attlist">
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="formula_And.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="reOr-Query.attlist">
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="formula_Or.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="op_Atom.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="card.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="closure.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="id.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="oid.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="direction.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="reData.attlist">
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="left.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="right.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="torso.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="reExpr.attlist">
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
    <xs:attribute name="style" type="ruleml:style.value">
      <xs:annotation>
        <xs:documentation>@style: defines a reference to a corresponding unique key. See
          http://www.reaction.ruleml.org/1.02/glossary/#gloss-@style</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="op_Expr.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="degree.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="body_Implies.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="head_Implies.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="rearg.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="iri.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="material.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="reEntails.attlist">
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="body_Entails.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="head_Entails.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="strong.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="weak.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="reRuleML.attlist">
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="react.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="reAssertRetract.attlist">
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="reQuery.attlist">
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="formula_AssertRetract.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="formula_Query.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="rePlex.attlist">
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
    <xs:attribute name="style" type="ruleml:style.value">
      <xs:annotation>
        <xs:documentation>@style: defines a reference to a corresponding unique key. See
          http://www.reaction.ruleml.org/1.02/glossary/#gloss-@style</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="declare.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="formula_Forall.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="formula_Exists.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="Reify-any.attlist">
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="Reify.attlist">
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="Reify-node.attlist">
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="reRulebase.attlist">
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="formula_Rulebase.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="repo.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="resl.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="oriented.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="interpretation.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="type.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="val.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="weight.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="commonNode.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <xs:group name="time_anycontent">
    <xs:sequence>
      <xs:element form="qualified" name="content" type="ruleml:time_anycontent.type"/>
    </xs:sequence>
  </xs:group>
  <xs:complexType name="time_anycontent.type">
    <xs:complexContent>
      <xs:extension base="ruleml:time_anycontent.content">
        <xs:attributeGroup ref="ruleml:time_anycontent.attlist"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="time_anycontent.content">
    <xs:complexContent>
      <xs:extension base="ruleml:anycontent.content"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:attributeGroup name="time_anycontent.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  
  <xs:group name="spatial_anycontent">
    <xs:sequence>
      <xs:element form="qualified" name="content" type="ruleml:spatial_anycontent.type"/>
    </xs:sequence>
  </xs:group>
  <xs:complexType name="spatial_anycontent.type">
    <xs:complexContent>
      <xs:extension base="ruleml:spatial_anycontent.content">
        <xs:attributeGroup ref="ruleml:spatial_anycontent.attlist"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="spatial_anycontent.content">
    <xs:complexContent>
      <xs:extension base="ruleml:anycontent.content"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:attributeGroup name="spatial_anycontent.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  
  <xs:group name="arg_interval.choice">
    <xs:choice>
      <xs:group ref="ruleml:interval_anycontent"/>
      <xs:group ref="ruleml:arg_interval.def"/>
    </xs:choice>
  </xs:group>
  <xs:group name="interval_anycontent">
    <xs:sequence>
      <xs:element form="qualified" name="content" type="ruleml:interval_anycontent.type"/>
    </xs:sequence>
  </xs:group>
  <xs:complexType name="interval_anycontent.type">
    <xs:complexContent>
      <xs:extension base="ruleml:interval_anycontent.content">
        <xs:attributeGroup ref="ruleml:interval_anycontent.attlist"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="interval_anycontent.content">
    <xs:complexContent>
      <xs:extension base="ruleml:anycontent.content"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:attributeGroup name="interval_anycontent.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  
  <xs:group name="foreign-element">
    <xs:choice>
      <xs:any namespace="##other" processContents="lax"/>
      <xs:any namespace="##local" processContents="lax"/>
    </xs:choice>
  </xs:group>
  <xs:group name="anything">
    <xs:sequence>
      <xs:any maxOccurs="unbounded" minOccurs="0" processContents="lax"/>
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="anything">
    <xs:anyAttribute processContents="skip"/>
  </xs:attributeGroup>
  
  
  <xs:attributeGroup name="style.attrib">
    <xs:attributeGroup ref="ruleml:style-att.choice"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="style-att.choice">
    <xs:attributeGroup ref="ruleml:style.attrib.def"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="style.attrib.def">
    <xs:attribute name="style" type="ruleml:style.value" use="required">
      <xs:annotation>
        <xs:documentation>@style: defines a reference to a corresponding unique key. See
          http://www.reaction.ruleml.org/1.02/glossary/#gloss-@style</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:simpleType name="style.value">
    <xs:union memberTypes="ruleml:PrefixedCURIE.datatype ruleml:AbsIRI.datatype">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="reasoning/single-valued"/>
        </xs:restriction>
      </xs:simpleType>
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="reasoning/multi-valued"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>
  
  <xs:attributeGroup name="generic-Node.attlist">
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
    <xs:attribute name="type" type="ruleml:type.value">
      <xs:annotation>
        <xs:documentation>A role for optionally specifying a term's (user-defined) type. See
          http://ruleml.org/1.02/glossary/#gloss-type</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="iri" type="ruleml:iri.value">
      <xs:annotation>
        <xs:documentation>An attribute for referring to a IRI.     See
          http://ruleml.org/1.02/glossary/#gloss-@iri</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="style" type="ruleml:style.value">
      <xs:annotation>
        <xs:documentation>@style: defines a reference to a corresponding unique key. See
          http://www.reaction.ruleml.org/1.02/glossary/#gloss-@style</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  
  <xs:attributeGroup name="formula-interface-ext.attlist">
    <xs:attribute name="style" type="ruleml:style.value">
      <xs:annotation>
        <xs:documentation>@style: defines a reference to a corresponding unique key. See
          http://www.reaction.ruleml.org/1.02/glossary/#gloss-@style</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="formula-interface.attlist">
    <xs:attributeGroup ref="ruleml:formula-interface-ext.attlist"/>
    <xs:attributeGroup ref="ruleml:closure-att.choice"/>
  </xs:attributeGroup>
  
  <xs:attributeGroup name="operator-interface-ext.attlist">
    <xs:attribute name="style" type="ruleml:style.value">
      <xs:annotation>
        <xs:documentation>@style: defines a reference to a corresponding unique key. See
          http://www.reaction.ruleml.org/1.02/glossary/#gloss-@style</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="operator-interface.attlist">
    <xs:attributeGroup ref="ruleml:operator-interface-ext.attlist"/>
    <xs:attributeGroup ref="ruleml:closure-att.choice"/>
  </xs:attributeGroup>
  
  
  
  
  
  
  <xs:attributeGroup name="key-att.choice">
    <xs:annotation>
      <xs:documentation>@key: defines a unique key attribute which can be used for distributed
        referencing from a keyref attribute. See
        http://www.reaction.ruleml.org/1.02/glossary/#gloss-@key</xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="ruleml:key.attrib.def"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="key.attrib.def">
    <xs:attribute name="key" type="ruleml:key.value" use="required"/>
  </xs:attributeGroup>
  <xs:simpleType name="key.value">
    <xs:union memberTypes="ruleml:PrefixedCURIE.datatype ruleml:AbsIRI.datatype"/>
  </xs:simpleType>
  <xs:attributeGroup name="keyref-att.choice">
    <xs:annotation>
      <xs:documentation>@keyref: defines a reference to a corresponding unique key. See
        http://www.reaction.ruleml.org/1.02/glossary/#gloss-@keyref</xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="ruleml:keyref.attrib.def"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="keyref.attrib.def">
    <xs:attribute name="keyref" type="ruleml:keyref.value" use="required"/>
  </xs:attributeGroup>
  <xs:simpleType name="keyref.value">
    <xs:union memberTypes="ruleml:PrefixedCURIE.datatype ruleml:AbsIRI.datatype"/>
  </xs:simpleType>
  
  
  
  
  
  
  <xs:attributeGroup name="Interval_term.attlist">
    <xs:attribute name="type" type="ruleml:type.value">
      <xs:annotation>
        <xs:documentation>A role for optionally specifying a term's (user-defined) type. See
          http://ruleml.org/1.02/glossary/#gloss-type</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="Interval_formula.attlist">
    <xs:attributeGroup ref="ruleml:formula-interface.attlist"/>
    <xs:attribute name="type" type="ruleml:type.value">
      <xs:annotation>
        <xs:documentation>A role for optionally specifying a term's (user-defined) type. See
          http://ruleml.org/1.02/glossary/#gloss-type</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
  </xs:attributeGroup>
  <xs:complexType name="Interval_term.content">
    <xs:sequence minOccurs="0">
      <xs:group ref="ruleml:arg_interval.choice"/>
      <xs:group minOccurs="0" ref="ruleml:arg_interval.choice"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="Interval_formula.content">
    <xs:sequence>
      <xs:group ref="ruleml:Interval_formula.header"/>
      <xs:sequence minOccurs="0">
        <xs:group ref="ruleml:arg_interval.choice"/>
        <xs:group minOccurs="0" ref="ruleml:arg_interval.choice"/>
      </xs:sequence>
    </xs:sequence>
  </xs:complexType>
  <xs:group name="Interval_formula.header">
    <xs:sequence>
      <xs:group minOccurs="0" ref="ruleml:Atom.header"/>
    </xs:sequence>
  </xs:group>
  
  <xs:complexType name="Interval_term.type.def">
    <xs:complexContent>
      <xs:extension base="ruleml:Interval_term.content">
        <xs:attributeGroup ref="ruleml:Interval_term.attlist"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Interval_formula.type.def">
    <xs:complexContent>
      <xs:extension base="ruleml:Interval_formula.content">
        <xs:attributeGroup ref="ruleml:Interval_formula.attlist"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:group name="Interval_term.def">
    <xs:sequence>
      <xs:element form="qualified" name="Interval" type="ruleml:Interval_term.type.def">
        <xs:annotation>
          <xs:documentation>&lt;Interval&gt;: generic Interval element. See
            http://www.reaction.ruleml.org/1.02/glossary/#gloss-Interval</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:group name="Interval_formula.def">
    <xs:sequence>
      <xs:element form="qualified" name="Interval" type="ruleml:Interval_formula.type.def"/>
    </xs:sequence>
  </xs:group>
  
  <xs:attributeGroup name="arg_interval.attlist">
    <xs:attributeGroup ref="ruleml:index-attrib.choice"/>
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:complexType name="arg_interval.content">
    <xs:complexContent>
      <xs:extension base="ruleml:interval_primitives.content"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="arg_interval.type.def">
    <xs:complexContent>
      <xs:extension base="ruleml:arg_interval.content">
        <xs:attributeGroup ref="ruleml:arg_interval.attlist"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:group name="arg_interval.def">
    <xs:sequence>
      <xs:element form="qualified" name="arg" type="ruleml:arg_interval.type.def"/>
    </xs:sequence>
  </xs:group>
  
  <xs:complexType name="interval_primitives.content">
    <xs:annotation>
      <xs:documentation>Interval primitives</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:group ref="ruleml:arg.content"/>
      <xs:group ref="ruleml:interval_algebra_group.content"/>
    </xs:choice>
  </xs:complexType>
  
  
  
  <xs:attributeGroup name="Negation.attlist">
    <xs:annotation>
      <xs:documentation>the Negation attribute list</xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="ruleml:generic-Node.attlist"/>
  </xs:attributeGroup>
  <xs:complexType name="Negation.content">
    <xs:complexContent>
      <xs:extension base="ruleml:formula-negation.choice"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="formula-negation.choice">
    <xs:group ref="ruleml:formula-negation"/>
  </xs:complexType>
  <xs:complexType name="Negation.type.def">
    <xs:complexContent>
      <xs:extension base="ruleml:Negation.content">
        <xs:attributeGroup ref="ruleml:Negation.attlist"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name="Negation" type="ruleml:Negation.type.def">
    <xs:annotation>
      <xs:documentation>&lt;Negation&gt;: a generic polymorphic negation, which is interpreted by the
        intended semantics (i.e. semantic profile). See
        http://www.reaction.ruleml.org/1.02/glossary/#gloss-Negation</xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:attributeGroup name="formula-negation.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:complexType name="formula-negation.content">
    <xs:complexContent>
      <xs:extension base="ruleml:NegFormula.choice"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="formula-negation.type.def">
    <xs:complexContent>
      <xs:extension base="ruleml:formula-negation.content">
        <xs:attributeGroup ref="ruleml:formula-negation.attlist"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:group name="formula-negation">
    <xs:sequence>
      <xs:element form="qualified" name="formula" type="ruleml:formula-negation.type.def"/>
    </xs:sequence>
  </xs:group>
  
  
  
  <xs:attributeGroup name="Operation.attlist">
    <xs:annotation>
      <xs:documentation>the Operation attribute list</xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="ruleml:generic-Node.attlist"/>
  </xs:attributeGroup>
  <xs:complexType name="Operation.content">
    <xs:group maxOccurs="unbounded" minOccurs="0" ref="ruleml:formula-Operation.choice"/>
  </xs:complexType>
  <xs:group name="formula-Operation.choice">
    <xs:sequence>
      <xs:group ref="ruleml:formula-Operation"/>
    </xs:sequence>
  </xs:group>
  <xs:complexType name="Operation.type.def">
    <xs:complexContent>
      <xs:extension base="ruleml:Operation.content">
        <xs:attributeGroup ref="ruleml:Operation.attlist"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name="Operation" type="ruleml:Operation.type.def">
    <xs:annotation>
      <xs:documentation>&lt;Operation&gt;: a generic polymorphic Operation, which is interpreted by the
        intended semantics (i.e. semantic profile). See
        http://www.reaction.ruleml.org/1.02/glossary/#gloss-Operation</xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:group name="Operation-node.choice">
    <xs:sequence>
      <xs:element ref="ruleml:Operation"/>
    </xs:sequence>
  </xs:group>
  
  <xs:attributeGroup name="formula-Operation.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:complexType name="formula_Operation.content">
    <xs:complexContent>
      <xs:extension base="ruleml:AndFormula.choice"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="formula-Operation.type.def">
    <xs:complexContent>
      <xs:extension base="ruleml:formula_Operation.content">
        <xs:attributeGroup ref="ruleml:formula-Operation.attlist"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:group name="formula-Operation">
    <xs:sequence>
      <xs:element form="qualified" name="formula" type="ruleml:formula-Operation.type.def"/>
    </xs:sequence>
  </xs:group>
  
  
  <xs:group name="Rule-node.choice">
    <xs:sequence>
      <xs:element ref="ruleml:Rule"/>
    </xs:sequence>
  </xs:group>
  <xs:element name="Rule" type="ruleml:Rule.type.def">
    <xs:annotation>
      <xs:documentation>&lt;Rule&gt;: defines a rule in Consumer RuleML. See
        http://www.reaction.ruleml.org/1.02/glossary/#gloss-Rule</xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="Rule.type.def">
    <xs:complexContent>
      <xs:extension base="ruleml:Rule.content">
        <xs:attributeGroup ref="ruleml:Rule-datt.choice"/>
        <xs:attributeGroup ref="ruleml:reRule.attlist"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:attributeGroup name="Rule-datt.choice">
    <xs:attributeGroup ref="ruleml:material-att-inf.choice"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="reRule.attlist">
    <xs:attributeGroup ref="ruleml:operator-interface.attlist"/>
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
  </xs:attributeGroup>
  <xs:complexType name="Rule.content">
    <xs:sequence>
      <xs:group ref="ruleml:Rule.header"/>
      <xs:group minOccurs="0" ref="ruleml:Rule.main"/>
    </xs:sequence>
  </xs:complexType>
  
  
  <xs:group name="if_Rule-edge.choice">
    <xs:annotation>
      <xs:documentation/>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:if_Rule.edge.def"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="if_Rule.edge.def">
    <xs:sequence>
      <xs:element form="qualified" name="if" type="ruleml:if_Rule.type.def">
        <xs:annotation>
          <xs:documentation>&lt;if&gt;: contains the premises of the rule. See
            http://www.reaction.ruleml.org/1.02/glossary/#gloss-if</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:complexType name="if_Rule.type.def">
    <xs:complexContent>
      <xs:extension base="ruleml:if_Rule.content">
        <xs:attributeGroup ref="ruleml:if_Rule.attlist"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="if_Rule.content">
    <xs:complexContent>
      <xs:extension base="ruleml:PremiseFormula.choice"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:attributeGroup name="if_Rule.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  
  <xs:group name="then_Rule-edge.choice">
    <xs:sequence>
      <xs:group ref="ruleml:then_Rule.edge.def"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="then_Rule.edge.def">
    <xs:sequence>
      <xs:element form="qualified" name="then" type="ruleml:then_Rule.type.def">
        <xs:annotation>
          <xs:documentation>&lt;then&gt;: contains the conclusion of the rule. See
            http://www.reaction.ruleml.org/1.02/glossary/#gloss-then</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:complexType name="then_Rule.type.def">
    <xs:complexContent>
      <xs:extension base="ruleml:then_Rule.content">
        <xs:attributeGroup ref="ruleml:then_Rule.attlist"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="then_Rule.content">
    <xs:complexContent>
      <xs:extension base="ruleml:ConclusionFormula.choice"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:attributeGroup name="then_Rule.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  
  
  <xs:group name="Spatial_formula-node.choice">
    <xs:sequence>
      <xs:group ref="ruleml:Spatial_formula.def"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="Spatial_term-node.choice">
    <xs:sequence>
      <xs:group ref="ruleml:Spatial_term.def"/>
    </xs:sequence>
  </xs:group>
  
  <xs:attributeGroup name="Spatial_term.attlist">
    <xs:attribute name="type" type="ruleml:type.value">
      <xs:annotation>
        <xs:documentation>A role for optionally specifying a term's (user-defined) type. See
          http://ruleml.org/1.02/glossary/#gloss-type</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="Spatial_formula.attlist">
    <xs:attributeGroup ref="ruleml:formula-interface.attlist"/>
    <xs:attribute name="type" type="ruleml:type.value">
      <xs:annotation>
        <xs:documentation>A role for optionally specifying a term's (user-defined) type. See
          http://ruleml.org/1.02/glossary/#gloss-type</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
  </xs:attributeGroup>
  <xs:complexType name="Spatial_term.content">
    <xs:group ref="ruleml:argumentsForSpatial.sequence"/>
  </xs:complexType>
  <xs:complexType name="Spatial_formula.content">
    <xs:sequence>
      <xs:group ref="ruleml:Spatial_formula.header"/>
      <xs:group ref="ruleml:argumentsForSpatial.sequence"/>
    </xs:sequence>
  </xs:complexType>
  <xs:group name="Spatial_formula.header">
    <xs:sequence>
      <xs:group minOccurs="0" ref="ruleml:Atom.header"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="arg_spatial.choice">
    <xs:sequence>
      <xs:group ref="ruleml:arg_spatial"/>
    </xs:sequence>
  </xs:group>
  <xs:complexType name="Spatial_term.type.def">
    <xs:complexContent>
      <xs:extension base="ruleml:Spatial_term.content">
        <xs:attributeGroup ref="ruleml:Spatial_term.attlist"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Spatial_formula.type.def">
    <xs:complexContent>
      <xs:extension base="ruleml:Spatial_formula.content">
        <xs:attributeGroup ref="ruleml:Spatial_formula.attlist"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:group name="Spatial_term.def">
    <xs:sequence>
      <xs:element form="qualified" name="Spatial" type="ruleml:Spatial_term.type.def">
        <xs:annotation>
          <xs:documentation>&lt;Spatial&gt;: generic Spatial element. See
            http://www.reaction.ruleml.org/1.02/glossary/#gloss-Spatial</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:group name="Spatial_formula.def">
    <xs:sequence>
      <xs:element form="qualified" name="Spatial" type="ruleml:Spatial_formula.type.def"/>
    </xs:sequence>
  </xs:group>
  
  <xs:attributeGroup name="arg_spatial.attlist">
    <xs:attributeGroup ref="ruleml:index-attrib.choice"/>
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
  </xs:attributeGroup>
  <xs:complexType name="arg_spatial.content">
    <xs:complexContent>
      <xs:extension base="ruleml:spatial_primitives.content"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="arg_spatial.type.def">
    <xs:complexContent>
      <xs:extension base="ruleml:arg_spatial.content">
        <xs:attributeGroup ref="ruleml:arg_spatial.attlist"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:group name="arg_spatial">
    <xs:sequence>
      <xs:element form="qualified" name="arg" type="ruleml:arg_spatial.type.def"/>
    </xs:sequence>
  </xs:group>
  
  <xs:complexType name="spatial_primitives.content">
    <xs:annotation>
      <xs:documentation>An internal group for the spatial primitives for interpretation as
        spatial</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:group ref="ruleml:arg.content"/>
      <xs:group ref="ruleml:spatial_temporal_algebra_group.content"/>
    </xs:choice>
  </xs:complexType>
  
  
  <xs:group name="spatial_temporal_algebra_group.content">
    <xs:choice>
      <xs:element ref="ruleml:After"/>
      <xs:element ref="ruleml:Before"/>
      <xs:element ref="ruleml:Every"/>
      <xs:element ref="ruleml:Any"/>
      <xs:element ref="ruleml:Timer"/>
    </xs:choice>
  </xs:group>
  
  <xs:group name="interval_algebra_group.content">
    <xs:choice>
      <xs:element ref="ruleml:During"/>
      <xs:element ref="ruleml:Overlaps"/>
      <xs:element ref="ruleml:Starts"/>
      <xs:element ref="ruleml:Precedes"/>
      <xs:element ref="ruleml:Succeeds"/>
      <xs:element ref="ruleml:Meets"/>
      <xs:group ref="ruleml:IntervalAlgebraEqual"/>
      <xs:element ref="ruleml:Finishes"/>
    </xs:choice>
  </xs:group>
  
  <xs:group name="IntervalAlgebraEqual">
    <xs:sequence>
      <xs:element form="qualified" name="Equal" type="ruleml:IntervalAlgebraOperation.type.def"/>
    </xs:sequence>
  </xs:group>
  
  <xs:attributeGroup name="IntervalAlgebraOperation.attlist">
    <xs:attributeGroup ref="ruleml:operator-interface.attlist"/>
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
  </xs:attributeGroup>
  
  <xs:attributeGroup name="After.attlist">
    <xs:attributeGroup ref="ruleml:IntervalAlgebraOperation.attlist"/>
  </xs:attributeGroup>
  <xs:complexType name="After.content">
    <xs:complexContent>
      <xs:extension base="ruleml:Interval_term.content"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="After.type.def">
    <xs:complexContent>
      <xs:extension base="ruleml:After.content">
        <xs:attributeGroup ref="ruleml:After.attlist"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name="After" type="ruleml:After.type.def">
    <xs:annotation>
      <xs:documentation>&lt;After&gt;: a temporal operator "t2 after t1". See
        http://www.reaction.ruleml.org/1.02/glossary/#gloss-After  </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Before" type="ruleml:After.type.def">
    <xs:annotation>
      <xs:documentation>&lt;Before&gt;: a temporal operator "t1 before t2". See
        http://www.reaction.ruleml.org/1.02/glossary/#gloss-After</xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:attributeGroup name="Every.attlist">
    <xs:attributeGroup ref="ruleml:IntervalAlgebraOperation.attlist"/>
  </xs:attributeGroup>
  <xs:complexType name="Every.content">
    <xs:group minOccurs="0" ref="ruleml:arg_interval.choice"/>
  </xs:complexType>
  <xs:complexType name="Every.type.def">
    <xs:complexContent>
      <xs:extension base="ruleml:Every.content">
        <xs:attributeGroup ref="ruleml:Every.attlist"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name="Every" type="ruleml:Every.type.def">
    <xs:annotation>
      <xs:documentation>&lt;Every&gt;: a temporal operator "every t". See
        http://www.reaction.ruleml.org/1.02/glossary/#gloss-Every</xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:attributeGroup name="Any.attlist">
    <xs:attributeGroup ref="ruleml:IntervalAlgebraOperation.attlist"/>
  </xs:attributeGroup>
  <xs:complexType name="Any.content">
    <xs:group maxOccurs="unbounded" minOccurs="0" ref="ruleml:arg_interval.choice"/>
  </xs:complexType>
  <xs:complexType name="Any.type.def">
    <xs:complexContent>
      <xs:extension base="ruleml:Any.content">
        <xs:attributeGroup ref="ruleml:Any.attlist"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name="Any" type="ruleml:Any.type.def">
    <xs:annotation>
      <xs:documentation>&lt;Any&gt;: a temporal operator "any t1, .., tn". See
        http://www.reaction.ruleml.org/1.02/glossary/#gloss-Any</xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:attributeGroup name="Timer.attlist">
    <xs:attributeGroup ref="ruleml:IntervalAlgebraOperation.attlist"/>
  </xs:attributeGroup>
  <xs:complexType name="Timer.content">
    <xs:complexContent>
      <xs:extension base="ruleml:Interval_term.content"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Timer.type.def">
    <xs:complexContent>
      <xs:extension base="ruleml:Timer.content">
        <xs:attributeGroup ref="ruleml:Timer.attlist"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name="Timer" type="ruleml:Timer.type.def">
    <xs:annotation>
      <xs:documentation>&lt;Timer&gt;: a temporal operator "After t Every tx". See
        http://www.reaction.ruleml.org/1.02/glossary/#gloss-Timer</xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:complexType name="IntervalAlgebraOperation.content">
    <xs:sequence>
      <xs:group ref="ruleml:arg_interval.choice"/>
      <xs:group ref="ruleml:arg_interval.choice"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="IntervalAlgebraOperation.type.def">
    <xs:complexContent>
      <xs:extension base="ruleml:IntervalAlgebraOperation.content">
        <xs:attributeGroup ref="ruleml:IntervalAlgebraOperation.attlist"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name="During" type="ruleml:IntervalAlgebraOperation.type.def">
    <xs:annotation>
      <xs:documentation>&lt;During&gt;: an interval operator. See
        http://www.reaction.ruleml.org/1.02/glossary/#gloss-During</xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Overlaps" type="ruleml:IntervalAlgebraOperation.type.def">
    <xs:annotation>
      <xs:documentation>&lt;Overlaps&gt;: an interval operator. See
        http://www.reaction.ruleml.org/1.02/glossary/#gloss-Overlaps</xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Starts" type="ruleml:IntervalAlgebraOperation.type.def">
    <xs:annotation>
      <xs:documentation>&lt;Starts&gt;: an interval operator. See
        http://www.reaction.ruleml.org/1.02/glossary/#gloss-Starts</xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Precedes" type="ruleml:IntervalAlgebraOperation.type.def">
    <xs:annotation>
      <xs:documentation>&lt;Precedes&gt;: an interval operator. See
        http://www.reaction.ruleml.org/1.02/glossary/#gloss-Precedes</xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Succeeds" type="ruleml:IntervalAlgebraOperation.type.def">
    <xs:annotation>
      <xs:documentation>&lt;Succeeds&gt;: an interval operator. See
        http://www.reaction.ruleml.org/1.02/glossary/#gloss-Succeeds</xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Meets" type="ruleml:IntervalAlgebraOperation.type.def">
    <xs:annotation>
      <xs:documentation>&lt;Meets&gt;: an interval operator. See
        http://www.reaction.ruleml.org/1.02/glossary/#gloss-Meets</xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Finishes" type="ruleml:IntervalAlgebraOperation.type.def">
    <xs:annotation>
      <xs:documentation>&lt;Finishes&gt;: an interval operator. See
        http://www.reaction.ruleml.org/1.02/glossary/#gloss-Finishes</xs:documentation>
    </xs:annotation>
  </xs:element>
  
  
  
  
  <xs:group name="Time_formula-node.choice">
    <xs:sequence>
      <xs:group ref="ruleml:Time_formula.def"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="Time_term-node.choice">
    <xs:sequence>
      <xs:group ref="ruleml:Time_term.def"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="arg_time.choice">
    <xs:sequence>
      <xs:group ref="ruleml:arg_time.def"/>
    </xs:sequence>
  </xs:group>
  
  <xs:group name="Time_term.def">
    <xs:sequence>
      <xs:element form="qualified" name="Time" type="ruleml:Time_term.type.def">
        <xs:annotation>
          <xs:documentation>&lt;Time&gt;: generic Time element. See
            http://www.reaction.ruleml.org/1.02/glossary/#gloss-Time</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:complexType name="Time_term.type.def">
    <xs:complexContent>
      <xs:extension base="ruleml:Time_term.content">
        <xs:attributeGroup ref="ruleml:Time_term.attlist"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:attributeGroup name="Time_term.attlist">
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
    <xs:attribute name="type" type="ruleml:type.value">
      <xs:annotation>
        <xs:documentation>A role for optionally specifying a term's (user-defined) type. See
          http://ruleml.org/1.02/glossary/#gloss-type</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  
  <xs:group name="Time_formula.def">
    <xs:sequence>
      <xs:element form="qualified" name="Time" type="ruleml:Time_formula.type.def"/>
    </xs:sequence>
  </xs:group>
  <xs:complexType name="Time_formula.type.def">
    <xs:complexContent>
      <xs:extension base="ruleml:Time_formula.content">
        <xs:attributeGroup ref="ruleml:Time_formula.attlist"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:attributeGroup name="Time_formula.attlist">
    <xs:attributeGroup ref="ruleml:commonNode.attlist"/>
    <xs:attributeGroup ref="ruleml:formula-interface.attlist"/>
    <xs:attribute name="type" type="ruleml:type.value">
      <xs:annotation>
        <xs:documentation>A role for optionally specifying a term's (user-defined) type. See
          http://ruleml.org/1.02/glossary/#gloss-type</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  
  <xs:complexType name="Time_term.content">
    <xs:group ref="ruleml:argumentsForTime.sequence"/>
  </xs:complexType>
  <xs:complexType name="Time_formula.content">
    <xs:sequence>
      <xs:group ref="ruleml:Time_formula.header"/>
      <xs:group ref="ruleml:argumentsForTime.sequence"/>
    </xs:sequence>
  </xs:complexType>
  <xs:group name="Time_formula.header">
    <xs:sequence>
      <xs:group minOccurs="0" ref="ruleml:Atom.header"/>
    </xs:sequence>
  </xs:group>
  
  
  <xs:group name="arg_time.def">
    <xs:sequence>
      <xs:element form="qualified" name="arg" type="ruleml:arg_time.type.def"/>
    </xs:sequence>
  </xs:group>
  <xs:complexType name="arg_time.type.def">
    <xs:complexContent>
      <xs:extension base="ruleml:arg_time.content">
        <xs:attributeGroup ref="ruleml:arg_time.attlist"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:attributeGroup name="arg_time.attlist">
    <xs:attributeGroup ref="ruleml:commonInit.attlist"/>
    <xs:attributeGroup ref="ruleml:index-attrib.choice"/>
  </xs:attributeGroup>
  <xs:complexType name="arg_time.content">
    <xs:complexContent>
      <xs:extension base="ruleml:time_primitives.content"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="time_primitives.content">
    <xs:annotation>
      <xs:documentation>An internal group for the time primitives for interpretation as
        time</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:group ref="ruleml:arg.content"/>
      <xs:group ref="ruleml:spatial_temporal_algebra_group.content"/>
    </xs:choice>
  </xs:complexType>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <xs:complexType mixed="true" name="anycontent.content">
    <xs:sequence>
      <xs:any maxOccurs="unbounded" minOccurs="0" processContents="lax"/>
    </xs:sequence>
  </xs:complexType>
  
  
  
  
  
  
  
  
  
</xs:schema>